(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["RiemannHilbert`",{"RiemannHilbert`Common`"}];


Begin["`Private`"];



RiemannHilbert`Cauchy::usage="Cauchy[f,z] evaluates the Cauchy transform \!\(\*FractionBox[\(1\), \(2\\\ \[Pi]\[NonBreakingSpace]I\)]\)\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - z\)]\)\[DifferentialD]t of an IFun f at a complex point z. Cauchy[ifunlist,z] evaluates the sum of the Cauchy transform of each element of ifunlist. Cauchy[\[PlusMinus]1,f,x] evaluates the left/right limit of Cauchy[f,x] for x on the domain of f. Cauchy[\[PlusMinus]1,flist] for CauchyBoundedQ[flist] true evaluates the Cauchy transform of flist on the points of flist, returning another list of IFuns.";
RiemannHilbert`Hilbert::usage="Hilbert[f,x] evaluates the Hilbert transform \!\(\*FractionBox[\(1\), \(\[Pi]\)]\)PV\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - x\)]\)\[DifferentialD]t of an IFun f at a point x on Domain[f].";
RiemannHilbert`RHSolve::usage="RHSolve[ifunlist] returns u such that IdentityMatrix[2] + CauchyTransform[u,z] has the jumps specified by ifunlist.";
RiemannHilbert`RHSolver::usage="RHSolver[ifunlist] constructs an anonymous function R that precomputes the matrices used in RHSolve, so that if the domain and points of ifunlist are the same as ifunlist2, then R[ifunlist2] == RHSolve[ifunlist2].";
RiemannHilbert`RHSolveTop::usage="RHSolveTop[ifunlist] returns the top row of RHSolve.";
RiemannHilbert`RHSolverTop::usage="RHSolverTop[ifunlist] constructs an anonymous function R that precomputes the matrices used in RHSolveTop, so that if the domain and points of ifunlist are the same as ifunlist2, then R[ifunlist2] == RHSolveTop[ifunlist2].";
RiemannHilbert`CauchyBoundedQ::usage=
"CauchyBoundedQ[ifunlist] Determines if the Cauchy transform of ifunlist is bounded (i.e., at each joint vertex of ifunlist the functions sum to zero)";

RiemannHilbert`CauchyOperator::usage=
"CauchyOperator[s,flist] returns a function C such that if glist has the same domain and number of points as flist, then C[glist] = Cauchy[s,glist]";
RiemannHilbert`AddIdentityMatrix::usage=
"Adds IdentityMatrix[2] to a list of ifuns.";
RiemannHilbert`CauchyMatrix;


RiemannHilbert`Cauchy;
RiemannHilbert`CauchyS;
Cauchy[lf_LFun,z_List]:=Cauchy[lf,#]&/@z;
Cauchy[s_,lf_LFun,z_List]:=Cauchy[s,lf,#]&/@z;

CauchyS[+1,lf_LFun?UnitCircleFunQ,z_]:=NonNegativeEvaluate[lf,z];
CauchyS[-1,lf_LFun?UnitCircleFunQ,z_]:=-NegativeEvaluate[lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]<=1.&)]:=CauchyS[+1,lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]>1.&)]:=CauchyS[-1,lf,z];
Cauchy[s_,lf_LFun?UnitCircleFunQ,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyS[s,lf,z];
Cauchy[s_,lf_LFun?UnitCircleFunQ,z_]:=Cauchy[lf,z];

Cauchy[f:LFun[_,_Curve],z_]:=Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[s_,f:LFun[_,_Curve],z_]/;DomainMemberQ[f,z]:=Total[Cauchy[s,f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[lf_LFun,z_]:=Cauchy[lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Cauchy[s_,lf_LFun,z_]:=Cauchy[s,lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
RiemannHilbert`Hilbert[lf_LFun,z_]:=I (Cauchy[+1,lf,z]+Cauchy[-1,lf,z]);



RiemannHilbert`CauchyInverse[+1,lf_LFun,z_]:=Cauchy[+1,lf,z];
CauchyInverse[-1,lf_LFun,z_]:=-Cauchy[-1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]<=1.:=CauchyInverse[+1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]>1.:=CauchyInverse[-1,lf,z];

RiemannHilbert`HilbertInverse[lf_LFun,z_]:=-I (CauchyInverse[+1,lf,z]-CauchyInverse[-1,lf,z]);


Cauchy[+1,lf_LFun?UnitCircleFunQ]:=NonNegativePart[lf];
Cauchy[-1,lf_LFun?UnitCircleFunQ]:=-NegativePart[lf];

Cauchy[s_,f:LFun[_,_Curve]]:=LFun[Cauchy[s,f,f//Points],f//Domain];

Cauchy[s_,lf_LFun]:=LFun[Cauchy[s,lf//ToUnitCircle]//Values,lf//Domain]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Hilbert[lf_LFun]:=I (Cauchy[+1,lf]+Cauchy[-1,lf]);

CauchyInverse[+1,lf_LFun]:=Cauchy[+1,lf];
CauchyInverse[-1,lf_LFun]:=-Cauchy[-1,lf];

HilbertInverse[lf_LFun]:=-I (CauchyInverse[+1,lf]-CauchyInverse[-1,lf]);


RiemannHilbert`FPCauchyBasis;


RiemannHilbert`CauchyBasis[_,_Integer,_?InfinityQ]:=0;
RiemannHilbert`CauchyBasisS[_,_,_Integer,_?InfinityQ]:=0;



CauchyBasis[f_?FunQ,k_,x_]:=CauchyBasis[f//Domain,k,x];
CauchyBasis[s_,f_?FunQ,k_,x_]:=CauchyBasis[s,f//Domain,k,x];

CauchyBasisS[f_?FunQ,k_,x_]:=CauchyBasisS[f//Domain,k,x];
CauchyBasisS[s_,f_?FunQ,k_,x_]:=CauchyBasisS[s,f//Domain,k,x];

CauchyBasisS[+1,UnitCircle,k_?Negative,z_]:=0 z;
CauchyBasisS[-1,UnitCircle,k_?Negative,z_]:=-z^k;
CauchyBasisS[+1,UnitCircle,0,z_List]:=OneVector[Length[z]];
CauchyBasisS[+1,UnitCircle,0,z_]:=1;
CauchyBasisS[+1,UnitCircle,k_?NonNegative,z_]:=z^k;
CauchyBasisS[-1,UnitCircle,k_?NonNegative,z_]:=0 z;


CauchyBasis[d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[d,k,#]&/@z;
CauchyBasis[s_?SignQ,d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[s,d,k,#]&/@z;


CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]<=1.&)]:=CauchyBasisS[+1,UnitCircle,k,z];
CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]>1.&)]:=CauchyBasisS[-1,UnitCircle,k,z];

CauchyBasis[s_,UnitCircle,k_Integer,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyBasisS[s,UnitCircle,k,z];
CauchyBasis[s_,UnitCircle,k_Integer,z_]:=CauchyBasis[UnitCircle,k,z];


CauchyBasis[d:Curve[_LFun],0,z_]:=Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],0,z_]:=Total[CauchyBasis[s,UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[s_?SignQ,d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[s,UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],i_Integer;;j_Integer,z_List]:=((Total/@CauchyBasis[s,UnitCircle,i;;j,#])&/@ComplexMapToCircle[d,z]//Transpose)-Count[ComplexMapToCircle[d,10^18],_?(Abs[#]<1&)]  ToList[BasisShiftList[i;;j,0]];


CauchyBasis[f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasis[s_,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasisS[s_,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasisS[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];


CauchyBasisS[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasisS[s,d,k,z],{k,i,j}]];
CauchyBasis[d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[d,k,z],{k,i,j}]];
CauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[s,d,k,z],{k,i,j}]];



FPCauchyBasis[s_,f_?FunQ,k_,g_?FunQ]:=FPCauchyBasis[s,f//Domain,k,g];

FPCauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,lf_]/;Domain[lf]~NEqual~d:=LFun[#,lf//Domain]&/@CauchyBasis[s,d,i;;j,lf//Points];

RiemannHilbert`CauchyMatrix[s_?SignQ,lf_LFun?ScalarFunQ,lf2_LFun]:=Transpose[(FiniteValues/@FPCauchyBasis[s,lf,Span@@(lf//FFT//IndexRange),lf2])].FiniteTransformMatrix[lf];


Clear[\[Psi]p,\[Psi]m,\[Phi]];
\[Phi][n_,z_]:=(1/2) z^(2 Floor[(n+1)/2] + 1) LerchPhi[z^2,1,1/2+ Floor[(n+1)/2] ];
\[Mu][n_,z_]:=ArcTanh[z]-\[Phi][n,z];
\[Mu][n_,z_]/;z~NEqual~1:=1/2 (-PolyGamma[0,1/2]+PolyGamma[0,1/2+Floor[(1+n)/2]])//N;
\[Mu][n_,z_]/;z==-1:=-\[Mu][n,1];

\[Mu]ms[m_,z_]:=\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 1\), \(m\)]
\*FractionBox[\(z^\((2\ j\  - 1)\)\), \(2\ j\  - 1\)]\);
\[Mu]S[n_,z_]:=\[Mu]ms[Floor[(n+1)/2],z];


RiemannHilbert`\[Psi]p[0,z_]:=ArcTanh[z]//N;

SetAttributes[\[Psi]pS,Listable];
\[Psi]pS[0,z_]:=ArcTanh[z];
\[Psi]pS[n_?Positive,z_]:=z^n( ArcTanh[z]-\[Mu]S[n,1/z]);
\[Psi]pS[n_?Negative,z_]:=z^n( ArcTanh[z]-\[Mu]S[-n-1,z]);
\[Psi]pS[n_?EvenQ,z_?ZeroQ]:=0.;
\[Psi]pS[n_?OddQ,z_?ZeroQ]:=-(1/n)//N;

\[Psi]p\[Phi][n_?Positive,z_]:=z^n( ArcTanh[z]-ArcTanh[1/z]+\[Phi][n,1/z]);
\[Psi]p\[Phi][n_?Negative,z_]:=z^n( \[Phi][-n-1,z]);
\[Psi]m\[Phi][n_?Positive,z_]:=z^n( \[Psi]m[0,z]-\[Mu][n,1/z]);
\[Psi]m\[Phi][n_?Negative,z_]:=z^n( \[Psi]m[0,z]-\[Mu][-n-1,z]);


\[Psi]pH[n_?Negative,z_]:=With[{M=Floor[(-n)/2]},(z^(n+1+2 M) 1/(1-z^2) Hypergeometric2F1[1,1,3/2+M,z^2/(z^2-1)])/(1+2 M)];
\[Psi]pH[n_?Positive,z_]:=With[{M=Floor[(n+1)/2]},z^n  (ArcTanh[z]-ArcTanh[1/z])+1/(1+2 M) z^(n-1-2 M) 1/(1-z^(-2))  Hypergeometric2F1[1,1,3/2+M,z^-2/(z^(-2)-1)]];
SetAttributes[\[Psi]p,Listable];

\[Psi]p[n_?EvenQ,z_?ZeroQ]:=0.;
\[Psi]p[n_?OddQ,z_?ZeroQ]:=-(1/n)//N;

\[Psi]p[n_?Positive,z_]:=\[Psi]pS[n,z//N]//N;
\[Psi]p[n_?Negative,z_]:=\[Psi]pH[n,z//N]//N;


RiemannHilbert`\[Psi]m[0,z_]:=ArcTanh[1/z];
\[Psi]m[n_,_?InfinityQ]:=0;
\[Psi]m\[Phi][n_?Negative,z_]:=With[{M=Floor[(-n)/2]},z^n (ArcTanh[1/z]-ArcTanh[z])+1/(1+2 M) z^(n+1+2 M) Hypergeometric2F1[1,1/2 +M,3/2+M,z^2]];
\[Psi]m\[Phi][n_?Positive,z_]:=With[{M=Floor[(n+1)/2]},(z^(n-1-2 M) Hypergeometric2F1[1,1/2+M,3/2+M,1/z^2])/(1+2 M)];

\[Psi]m[n_,z_]:=\[Psi]m\[Phi][n,z];


CauchyBasis[UnitInterval,k_Integer,x_]:=
-1/(I \[Pi])(\[Psi]p[k-1,IntervalToInnerCircle[x]]+\[Psi]p[-k+1,IntervalToInnerCircle[x]]);
CauchyBasis[+1,UnitInterval,k_Integer,x_]:=
-1/(I \[Pi])(\[Psi]p[k-1,IntervalToBottomCircle[x]]+\[Psi]p[-k+1,IntervalToBottomCircle[x]]);
CauchyBasis[-1,UnitInterval,k_Integer,x_]:=
-1/(I \[Pi])(\[Psi]p[k-1,IntervalToTopCircle[x]]+\[Psi]p[-k+1,IntervalToTopCircle[x]]);

CauchyBasis[f_?RightEndpointInfinityQ,k_Integer,z_]:=CauchyBasis[UnitInterval,k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,1,MapToInterval[f,z]]-1/(I \[Pi]) (\[Mu][k-1,1.]+\[Mu][k-2,1.]);

CauchyBasis[s_,f_?RightEndpointInfinityQ,k_Integer,z_]:=CauchyBasis[s,UnitInterval,k,MapToInterval[f,z]]-CauchyBasis[s,UnitInterval,1,MapToInterval[f,z]]-1/(I \[Pi]) (\[Mu][k-1,1.]+\[Mu][k-2,1.]);

CauchyBasis[f_?LeftEndpointInfinityQ,k_Integer,z_]:=CauchyBasis[UnitInterval,k,MapToInterval[f,z]]+(-1)^(k)CauchyBasis[UnitInterval,1,MapToInterval[f,z]]+(-1)^(k)/(I \[Pi]) (\[Mu][k-1,-1.]+\[Mu][k-2,-1.]);

CauchyBasis[s_,f_?LeftEndpointInfinityQ,k_Integer,z_]:=CauchyBasis[s,UnitInterval,k,MapToInterval[f,z]]+(-1)^(k)CauchyBasis[s,UnitInterval,1,MapToInterval[f,z]]+(-1)^(k)/(I \[Pi]) (\[Mu][k-1,-1.]+\[Mu][k-2,-1.]);

CauchyBasis[f_?IntervalDomainQ,k_Integer,z_]:=CauchyBasis[UnitInterval,k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,k,MapToInterval[f,\[Infinity]]];
CauchyBasis[s_,f_?IntervalDomainQ,k_Integer,z_]:=CauchyBasis[s,UnitInterval,k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,k,MapToInterval[f,\[Infinity]]];


\[Mu]msD[m_,z_]:=1+\!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 2\), \(m\)]\(z^\((2\ j\  - 2)\)\)\);
\[Mu]SD[n_,z_]:=\[Mu]msD[Floor[(n+1)/2],z];


RiemannHilbert`\[Psi]pD[0,z_]:=ArcTanh'[z]//N;

SetAttributes[\[Psi]pSD,Listable];
\[Psi]pSD[0,z_]:=ArcTanh[z];
\[Psi]pSD[n_?Positive,z_]:=n z^(n-1)( ArcTanh[z]-\[Mu]S[n,1/z])+z^n ( ArcTanh'[z]+1/z^2\[Mu]SD[n,1/z]);
\[Psi]pSD[n_?Negative,z_]:=n z^(n-1)( ArcTanh[z]-\[Mu]S[-n-1,z])+z^n ( ArcTanh'[z]-\[Mu]SD[-n-1,z]);

\[Psi]pHD[n_?Negative,z_]:=With[{M=Floor[(-n)/2]},1/(1+2 M) ((2 z^(2+2 M+n) Hypergeometric2F1[1,1,3/2+M,z^2/(-1+z^2)])/(1-z^2)^2+((1+2 M+n) z^(2 M+n) Hypergeometric2F1[1,1,3/2+M,z^2/(-1+z^2)])/(1-z^2)+(z^(1+2 M+n) (-((2 z^3)/(-1+z^2)^2)+(2 z)/(-1+z^2)) Hypergeometric2F1[2,2,5/2+M,z^2/(-1+z^2)])/((3/2+M) (1-z^2)))];
\[Psi]pHD[n_?Positive,z_]:=With[{M=Floor[(n+1)/2]},z^n ((n (-ArcTanh[1/z]+ArcTanh[z]))/z-(z^(-2 M) (1+n+z^2-n z^2+2 M (-1+z^2)) Hypergeometric2F1[1,1,3/2+M,1/(1-z^2)])/((1+2 M) (-1+z^2)^2)+(4 z^(2-2 M) Hypergeometric2F1[2,2,5/2+M,1/(1-z^2)])/((3+8 M+4 M^2) (-1+z^2)^3))];
SetAttributes[\[Psi]pD,Listable];

\[Psi]pD[n_?Positive,z_]:=\[Psi]pSD[n,z//N]//N;
\[Psi]pD[n_?Negative,z_]:=\[Psi]pHD[n,z//N]//N;


RiemannHilbert`CauchyBasisD[_,_Integer,_?InfinityQ]:=0;
CauchyBasisD[f_IFun,k_,x_]:=CauchyBasisD[f//Domain,k,x];
CauchyBasisD[s_,f_IFun,k_,x_]:=CauchyBasisD[s,f//Domain,k,x];

CauchyBasisD[UnitInterval,k_,x_]:=
-1/(I \[Pi])IntervalToInnerCircle'[x] (\[Psi]pD[k-1,IntervalToInnerCircle[x]] +\[Psi]pD[-k+1,IntervalToInnerCircle[x]]);
CauchyBasisD[+1,UnitInterval,k_,x_]:=
-1/(I \[Pi])IntervalToBottomCircle'[x](\[Psi]pD[k-1,IntervalToBottomCircle[x]]+\[Psi]pD[-k+1,IntervalToBottomCircle[x]]);
CauchyBasisD[-1,UnitInterval,k_,x_]:=
-1/(I \[Pi])IntervalToTopCircle[x](\[Psi]pD[k-1,IntervalToTopCircle[x]]+\[Psi]pD[-k+1,IntervalToTopCircle[x]]);

CauchyBasisD[f_?RightEndpointInfinityQ,k_,z_]:=MapToIntervalD[f,z](CauchyBasisD[UnitInterval,k,MapToInterval[f,z]]-CauchyBasisD[UnitInterval,1,MapToInterval[f,z]]);

CauchyBasisD[s_,f_?RightEndpointInfinityQ,k_,z_]:=MapToIntervalD[f,z](CauchyBasisD[s,UnitInterval,k,MapToInterval[f,z]]-CauchyBasisD[s,UnitInterval,1,MapToInterval[f,z]]);

CauchyBasisD[f_?LeftEndpointInfinityQ,k_,z_]:=MapToIntervalD[f,z](CauchyBasisD[UnitInterval,k,MapToInterval[f,z]]+(-1)^(k)CauchyBasisD[UnitInterval,1,MapToInterval[f,z]]);

CauchyBasisD[s_,f_?LeftEndpointInfinityQ,k_,z_]:=MapToIntervalD[f,z] (CauchyBasisD[s,UnitInterval,k,MapToInterval[f,z]]+(-1)^(k)CauchyBasisD[s,UnitInterval,1,MapToInterval[f,z]]);

CauchyBasisD[f_?DomainQ,k_,z_]:=MapToIntervalD[f,z] CauchyBasisD[UnitInterval,k,MapToInterval[f,z]];
CauchyBasisD[s_,f_?DomainQ,k_,z_]:=MapToIntervalD[f,z] CauchyBasisD[s,UnitInterval,k,MapToInterval[f,z]];



RiemannHilbert`LeftSingularityDataBasis[f_IFun,k_]:=LeftSingularityDataBasis[f//Domain,k];
LeftSingularityDataBasis[f_IFun,k_,t_]:=LeftSingularityDataBasis[f//Domain,k,t];
LeftSingularityDataBasis[s_,f_IFun,k_]:=LeftSingularityDataBasis[s,f//Domain,k];
RiemannHilbert`RightSingularityDataBasis[f_IFun,k_]:=RightSingularityDataBasis[f//Domain,k];
RightSingularityDataBasis[f_IFun,k_,t_]:=RightSingularityDataBasis[f//Domain,k,t];
RightSingularityDataBasis[s_,f_IFun,k_]:=RightSingularityDataBasis[s,f//Domain,k];

LeftSingularityDataBasis[UnitInterval,k_Integer]:={(-1)^(k-1) Log[2]/(2 I \[Pi])+(-1)^(k-1)/(I \[Pi]) (\[Mu][k-1,-1]+\[Mu][k-2,-1]),-(-1)^(k-1)/(2 I \[Pi]),-1};
RightSingularityDataBasis[UnitInterval,k_Integer]:={-Log[2]/(2 I \[Pi])+1/(I \[Pi]) (\[Mu][k-1,1]+\[Mu][k-2,1]),1/(2 I \[Pi]),1};


LeftSingularityDataBasis[f_?RightEndpointInfinityQ,k_Integer]:=LeftSingularityDataBasis[UnitInterval,k]//{#[[1]]-LeftSingularityDataBasis[UnitInterval,1][[1]]-1/(I \[Pi]) (\[Mu][k-1,1]+\[Mu][k-2,1])+#[[2]] Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]],#[[2]],#[[3]]Exp[I Arg[MapToIntervalD[f,f//LeftEndpoint]]]}&;
RightSingularityDataBasis[f_?LeftEndpointInfinityQ,k_Integer]:=RightSingularityDataBasis[UnitInterval,k]//{#[[1]]-(-1)^(k-1) RightSingularityDataBasis[UnitInterval,1][[1]]-(-1)^(k-1)/(I \[Pi]) (\[Mu][k-1,-1]+\[Mu][k-2,-1])+#[[2]] Log[Abs[MapToIntervalD[f,f//RightEndpoint]]],#[[2]],#[[3]]Exp[I Arg[MapToIntervalD[f,f//RightEndpoint]]]}&;


LeftSingularityDataBasis[f_?DomainQ,k_Integer]:=LeftSingularityDataBasis[UnitInterval,k]//{#[[1]]-CauchyBasis[UnitInterval,k,MapToInterval[f,\[Infinity]]]+#[[2]] Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]],#[[2]],#[[3]]Exp[I Arg[MapToIntervalD[f,f//LeftEndpoint]]]}&;
RightSingularityDataBasis[f_?DomainQ,k_Integer]:=RightSingularityDataBasis[UnitInterval,k]//{#[[1]]-CauchyBasis[UnitInterval,k,MapToInterval[f,\[Infinity]]]+#[[2]] Log[Abs[MapToIntervalD[f,f//RightEndpoint]]],#[[2]],#[[3]]Exp[I Arg[MapToIntervalD[f,f//RightEndpoint]]]}&;

LeftSingularityDataBasis[f_?DomainQ,k_Integer,t_?ScalarQ]:=LeftSingularityDataBasis[f,k]//{#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&;
LeftSingularityDataBasis[s_?SignQ,f_,k_Integer]:=LeftSingularityDataBasis[f,k]//{#[[1]]-#[[2]] I s \[Pi],#[[2]]}&;

RightSingularityDataBasis[f_?DomainQ,k_Integer,t_?ScalarQ]:=RightSingularityDataBasis[f,k]//{#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&;
RightSingularityDataBasis[s_?SignQ,f_,k_Integer]:=RightSingularityDataBasis[f,k]//{#[[1]]+#[[2]] I s \[Pi],#[[2]]}&;

RiemannHilbert`LeftSingularityData[f_IFun]:=Join[MapDot[Most[LeftSingularityDataBasis[f,#]]&,f//DCT],{LeftSingularityDataBasis[f,1]//Last}];
RiemannHilbert`RightSingularityData[f_IFun]:=Join[MapDot[Most[RightSingularityDataBasis[f,#]]&,f//DCT],{RightSingularityDataBasis[f,1]//Last}];

LeftSingularityData[f_IFun,t_?ScalarQ]:=LeftSingularityData[f]//{#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&;
LeftSingularityData[s_?(#==1||#==-1&),f_IFun]:=LeftSingularityData[f]//{#[[1]]-#[[2]] I s \[Pi],#[[2]]}&;

RightSingularityData[f_IFun,t_?ScalarQ]:=RightSingularityData[f]//{#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&;
RightSingularityData[s_?(#==1||#==-1&),f_IFun]:=RightSingularityData[f]//{#[[1]]+#[[2]] I s \[Pi],#[[2]]}&;



FPCauchyBasis[+1,UnitInterval,k_Integer,g_IFun?UnitIntervalFunQ]:=IFun[Module[{j},
Join[{LeftSingularityDataBasis[+1,UnitInterval,k]//First},-2(ArcTanh[IntervalToBottomCircle[Points[g]//Rest//Most]])/(I \[Pi]) ChebyshevT[k-1, Points[g]//Rest//Most]+(((PadRight[4 Riffle[Reverse[Table[1/j,{j,1.,k-1,2}]],0]//(If[OddQ[k],Join[{0},#],#]&),Length[g]])//HalfFirst//InverseDCT)/(2 I \[Pi])//Rest//Most),
{RightSingularityDataBasis[+1,UnitInterval,k]//First}]
],g//Domain];
FPCauchyBasis[-1,UnitInterval,k_Integer,g_IFun?UnitIntervalFunQ]:=IFun[Module[{j},
Join[{LeftSingularityDataBasis[-1,UnitInterval,k]//First},-2(ArcTanh[IntervalToTopCircle[Points[g]//Rest//Most]])/(I \[Pi]) ChebyshevT[k-1, Points[g]//Rest//Most]+(((PadRight[4 Riffle[Reverse[Table[1/j,{j,1.,k-1,2}]],0]//(If[OddQ[k],Join[{0},#],#]&),Length[g]])//HalfFirst//InverseDCT)/(2 I \[Pi])//Rest//Most),
{RightSingularityDataBasis[-1,UnitInterval,k]//First}]
],g//Domain];


FPCauchyBasis[s_?SignQ,f_?RightEndpointInfinityQ,k_Integer,g_IFun]/;f~NEqual~Domain[g]:=IFun[Values[FPCauchyBasis[s,UnitInterval,k,g//ToUnitInterval]]-Values[FPCauchyBasis[s,UnitInterval,1,g//ToUnitInterval]]-1/(I \[Pi]) (\[Mu][k-1,1.]+\[Mu][k-2,1.])//#+LeftSingularityDataBasis[UnitInterval,k][[2]] Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]] BasisVector[Length[#]][1]&
,g//Domain];
FPCauchyBasis[s_?SignQ,f_?LeftEndpointInfinityQ,k_Integer,g_]/;f~NEqual~Domain[g]:=IFun[Values[FPCauchyBasis[s,UnitInterval,k,g//ToUnitInterval]]+(-1)^(k)Values[FPCauchyBasis[s,UnitInterval,1,g//ToUnitInterval]]+(-1)^(k)/(I \[Pi]) (\[Mu][k-1,-1.]+\[Mu][k-2,-1.])//#+RightSingularityDataBasis[UnitInterval,k][[2]] Log[Abs[MapToIntervalD[f,f//RightEndpoint]]] BasisVector[Length[#]][-1]&
,g//Domain];


FPCauchyBasis[s_?SignQ,f_?DomainQ,k_Integer,g_IFun]/;f~NEqual~Domain[g]:=IFun[Values[FPCauchyBasis[s,UnitInterval,k,g//ToUnitInterval]]-CauchyBasis[UnitInterval,k,MapToInterval[f,\[Infinity]]]+RightSingularityDataBasis[UnitInterval,k][[2]]Log[Abs[MapToIntervalD[f,f//RightEndpoint]]] BasisVector[Length[g]][-1]+LeftSingularityDataBasis[UnitInterval,k][[2]]Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]] BasisVector[Length[g]][1],g//Domain];




FPCauchyBasis[_?SignQ,f_?(!RightEndpointInfinityQ[#]&&!LeftEndpointInfinityQ[#]&),k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]&&RightEndpoint[f]~NEqual~RightEndpoint[g]:=IFun[Join[{LeftSingularityDataBasis[f,k,LeftContourArg[g]]//First},
CauchyBasis[f,k,g//Points//Rest//Most],
{RightSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?(!RightEndpointInfinityQ[#]&&!LeftEndpointInfinityQ[#]&),k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]&&RightEndpoint[f]~NEqual~LeftEndpoint[g]:=IFun[Join[{RightSingularityDataBasis[f,k,LeftContourArg[g]]//First},
CauchyBasis[f,k,g//Points//Rest//Most],
{LeftSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];





FPCauchyBasis[_?SignQ,f_?DomainQ,k_Integer,g_IFun?RightEndpointInfinityQ]/;RightEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[Join[{RightSingularityDataBasis[f,k,LeftContourArg[g]]//First},
CauchyBasis[f,k,g//Points//Rest//Most],
{0}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?DomainQ,k_Integer,g_IFun?LeftEndpointInfinityQ]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[Join[{0},
CauchyBasis[f,k,g//Points//Most//Rest],
{LeftSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?DomainQ,k_Integer,g_IFun?LeftEndpointInfinityQ]/;RightEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[Join[{0},
CauchyBasis[f,k,g//Points//Most//Rest],
{RightSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?DomainQ,k_Integer,g_IFun?RightEndpointInfinityQ]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[Join[
{LeftSingularityDataBasis[f,k,LeftContourArg[g]]//First},
CauchyBasis[f,k,g//Points//Rest//Most],
{0}],Domain[g]];


FPCauchyBasis[_?SignQ,f_?(!RightEndpointInfinityQ[#]&),k_Integer,g_IFun]/;RightEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[Join[{RightSingularityDataBasis[f,k,LeftContourArg[g]]//First},
CauchyBasis[f,k,g//Points//Rest]],Domain[g]];
FPCauchyBasis[_?SignQ,f_?(!LeftEndpointInfinityQ[#]&),k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[Join[
(CauchyBasis[f,k,g//Points//Most]),
{LeftSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?(!RightEndpointInfinityQ[#]&),k_Integer,g_IFun]/;RightEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[Join[
(CauchyBasis[f,k,g//Points//Most]),
{RightSingularityDataBasis[f,k,RightContourArg[g]]//First}],Domain[g]];
FPCauchyBasis[_?SignQ,f_?(!LeftEndpointInfinityQ[#]&),k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[Join[
{LeftSingularityDataBasis[f,k,LeftContourArg[g]]//First},
(CauchyBasis[f,k,g//Points//Rest])],Domain[g]];



FPCauchyBasis[_?SignQ,f_?DomainQ,k_Integer,g_IFun]:=ZeroAtInfinityIFun[CauchyBasis[f,k,g//FinitePoints],Domain[g]];



\[Psi]pL[i_?Negative;;j_?Negative,x_]:=Module[{cur,k},
Join[{
cur=\[Psi]p[i,x]},
Table[If[EvenQ[k],
cur = cur x,
cur = cur x -1/k],{k,i+1,j}]]];

\[Psi]pL[i_?Positive;;j_?Positive,x_]:=Module[{cur,k},
Join[{
cur=\[Psi]p[i,x]},
Table[If[EvenQ[k],
cur = cur x,
cur = cur x -1/k],{k,i+1,j}]]];

\[Psi]pL[0;;j_?Positive,x_]:=Join[{\[Psi]p[0,x]},\[Psi]pL[1;;j,x]];
\[Psi]pL[i_?Negative;;0,x_]:=Join[\[Psi]pL[i;;-1,x],{\[Psi]p[0,x]}];
\[Psi]pL[i_?Negative;;j_?Positive,x_]:=Join[\[Psi]pL[i;;-1,x],{\[Psi]p[0,x]},\[Psi]pL[;;j,x]];


CauchyBasis[UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])(\[Psi]pL[i-1;;k-1,IntervalToInnerCircle[x]]+Reverse[\[Psi]pL[-k+1;;1-i,IntervalToInnerCircle[x]]]);
CauchyBasisS[+1,UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])(\[Psi]pL[i-1;;k-1,IntervalToBottomCircle[x]]+Reverse[\[Psi]pL[-k+1;;1-i,IntervalToBottomCircle[x]]]);
CauchyBasisS[-1,UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])(\[Psi]pL[i-1;;k-1,IntervalToTopCircle[x]]+Reverse[\[Psi]pL[-k+1;;1-i,IntervalToTopCircle[x]]]);


CauchyBasis[f:Curve[_IFun],1;;k_,z_List]:=MatrixMap[Total,CauchyBasis[UnitInterval,1;;k,ComplexMapToInterval[f,z]]];
CauchyBasis[s_,f:Curve[_IFun],1;;k_,z_List]:=MatrixMap[Total,CauchyBasis[s,UnitInterval,1;;k,ComplexMapToInterval[f,z]]];

CauchyBasis[f:Curve[_IFun],1;;k_,z_]:=Total/@CauchyBasis[UnitInterval,1;;k,ComplexMapToInterval[f,z]];
CauchyBasis[s_,f:Curve[_IFun],1;;k_,z_]:=Total/@CauchyBasis[s,UnitInterval,1;;k,ComplexMapToInterval[f,z]];

CauchyBasis[cr:Curve[cf_IFun,Stretch->L_],1;;k_,z_List]:=MatrixMap[Total,CauchyBasis[UnitInterval,1;;k,ComplexMapToInterval[cr,z]]]-((cf//Length)-1)CauchyBasis[UnitInterval,;;k,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];
CauchyBasis[s_,cr:Curve[cf_IFun,Stretch->L_],1;;k_,z_List]:=MatrixMap[Total,CauchyBasis[s,UnitInterval,1;;k,ComplexMapToInterval[cr,z]]]-((cf//Length)-1)CauchyBasis[UnitInterval,;;k,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];

CauchyBasis[cr:Curve[cf_IFun,Stretch->L_],1;;k_,z_]:=(Total/@CauchyBasis[UnitInterval,1;;k,ComplexMapToInterval[cr,z]])-((cf//Length)-1)CauchyBasis[UnitInterval,;;k,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];
CauchyBasis[s_,cr:Curve[cf_IFun,Stretch->L_],1;;k_,z_]:=(Total/@CauchyBasis[s,UnitInterval,1;;k,ComplexMapToInterval[cr,z]])-((cf//Length)-1)CauchyBasis[UnitInterval,;;k,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];


CauchyBasis[f_?RightEndpointInfinityQ,1;;k_,z_]:=CauchyBasis[UnitInterval,1;;k,MapToInterval[f,z]]//Function[mat,mat-Array[mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,1.]+\[Mu][#-2,1.])&,k]];
CauchyBasis[f_?LeftEndpointInfinityQ,1;;k_,z_]:=CauchyBasis[UnitInterval,1;;k,MapToInterval[f,z]]//Function[mat,mat+Array[(-1)^(#)(mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,-1.]+\[Mu][#-2,-1.]))&,k]];




CauchyBasisS[s_,f_?RightEndpointInfinityQ,1;;k_,z_]:=CauchyBasisS[s,UnitInterval,1;;k,MapToInterval[f,z]]//Function[mat,mat-Array[mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,1.]+\[Mu][#-2,1.])&,k]];
CauchyBasisS[s_,f_?LeftEndpointInfinityQ,1;;k_,z_]:=CauchyBasisS[s,UnitInterval,1;;k,MapToInterval[f,z]]//Function[mat,mat+Array[(-1)^(#)(mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,-1.]+\[Mu][#-2,-1.]))&,k]];


CauchyBasisS[s_,f_?IntervalDomainQ,1;;k_,z_]:=CauchyBasisS[s,UnitInterval,1;;k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,1;;k,MapToInterval[f,\[Infinity]]];


CauchyBasis[s_,d_?DomainQ,k_,x_?MatrixQ]:=CauchyBasis[s,d,k,#]&/@x//Transpose;

CauchyBasis[s_,d_?DomainQ,k_,x_List]:=
RightJoin@@
(If[DomainMemberQ[d,#//First],CauchyBasisS[s,d,k,#],CauchyBasis[d,k,#]]&/@SplitBy[x,DomainMemberQ[d,#]&]);



CauchyBasis[s_,d_?DomainQ,k_,x_]/;(DomainMemberQ[d,x]):=CauchyBasisS[s,d,k,x];
CauchyBasis[_,d_?IntervalDomainQ,k_,x_]:=CauchyBasis[UnitInterval,k,x];

CauchyBasis[f_?IntervalDomainQ,1;;k_,z_]:=CauchyBasis[UnitInterval,;;k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,;;k,MapToInterval[f,\[Infinity]]];
CauchyBasisS[s_,f_?IntervalDomainQ,1;;k_,z_]:=CauchyBasisS[s,UnitInterval,;;k,MapToInterval[f,z]]-CauchyBasis[UnitInterval,;;k,MapToInterval[f,\[Infinity]]];


LeftSingularityDataBasis[f:Curve[_IFun],1;;n_Integer]:=
Module[{pts,cb,lpD},
pts=Select[ComplexMapToInterval[f,f//LeftEndpoint],!(Abs[#+1]<100 $MachineTolerance)&];
lpD=MapToIntervalD[f,f//LeftEndpoint];
cb=Map[Total,CauchyBasis[UnitInterval,;;n,pts]];

({#[[1]]+#[[2]] Log[Abs[lpD]],#[[2]],#[[3]]Exp[I Arg[lpD]]}&/@LeftSingularityDataBasis[UnitInterval,;;n])+({#,0,0}&/@cb)
];

RightSingularityDataBasis[f:Curve[_IFun],1;;n_Integer]:=
Module[{pts,cb,lpD},
pts=Select[ComplexMapToInterval[f,f//RightEndpoint],!(Abs[#-1]<100 $MachineTolerance)&];
lpD=MapToIntervalD[f,f//RightEndpoint];
cb=Map[Total,CauchyBasis[UnitInterval,;;n,pts]];

({#[[1]]+#[[2]] Log[Abs[lpD]],#[[2]],#[[3]]Exp[I Arg[lpD]]}&/@RightSingularityDataBasis[UnitInterval,;;n])+({#,0,0}&/@cb)
];

LeftSingularityDataBasis[f:Curve[cf_IFun,Stretch->L_],1;;n_Integer]:=
Module[{pts,cb,lpD,cbinf},
pts=Select[ComplexMapToInterval[f,f//LeftEndpoint],!(Abs[#+1]<100 $MachineTolerance)&];
lpD=MapToIntervalD[f,f//LeftEndpoint];
cb=Map[Total,CauchyBasis[UnitInterval,;;n,pts]];
cbinf=((cf//Length)-1)CauchyBasis[UnitInterval,;;n,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];
({#[[1]]+#[[2]] Log[Abs[lpD]],#[[2]],#[[3]]Exp[I Arg[lpD]]}&/@LeftSingularityDataBasis[UnitInterval,;;n])+({#,0,0}&/@(cb-cbinf))
];

RightSingularityDataBasis[f:Curve[cf_IFun,Stretch->L_],1;;n_Integer]:=
Module[{pts,cb,lpD,cbinf},
pts=Select[ComplexMapToInterval[f,f//LeftEndpoint],!(Abs[#-1]<100 $MachineTolerance)&];
lpD=MapToIntervalD[f,f//RightEndpoint];
cb=Map[Total,CauchyBasis[UnitInterval,;;n,pts]];
cbinf=((cf//Length)-1)CauchyBasis[UnitInterval,;;n,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]];
({#[[1]]+#[[2]] Log[Abs[lpD]],#[[2]],#[[3]]Exp[I Arg[lpD]]}&/@RightSingularityDataBasis[UnitInterval,;;n])+({#,0,0}&/@(cb-cbinf))
];


LeftSingularityDataBasis[d_?IntervalDomainQ,1;;k_Integer]:=Array[LeftSingularityDataBasis[d,#]&,k];
RightSingularityDataBasis[d_?IntervalDomainQ,1;;k_Integer]:=Array[RightSingularityDataBasis[d,#]&,k];


LeftSingularityDataBasis[f_?IntervalDomainQ,1;;k_Integer,t_?ScalarQ]:={#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&/@LeftSingularityDataBasis[f,;;k];
LeftSingularityDataBasis[s_?SignQ,f_?IntervalDomainQ,1;;k_]:={#[[1]]-#[[2]] I s \[Pi],#[[2]]}&/@LeftSingularityDataBasis[f,;;k];

RightSingularityDataBasis[f_?IntervalDomainQ,1;;k_Integer,t_?ScalarQ]:={#[[1]]+#[[2]] I Arg[#[[3]] Exp[I t]],#[[2]]}&/@RightSingularityDataBasis[f,;;k];
RightSingularityDataBasis[s_?SignQ,f_,1;;k_]:={#[[1]]+#[[2]] I s \[Pi],#[[2]]}&/@RightSingularityDataBasis[f,;;k];



FPCauchyBasis[+1,UnitInterval,1;;n_Integer,g_IFun?UnitIntervalFunQ]:=Module[{mat,dctmat,j,k},
mat=ToeplitzMatrix[ZeroVector[n],
4 Riffle[Table[1/j,{j,1,n-1,2}],0]//(Join[{0},If[OddQ[n],Join[#,{0}],#]]&)];
dctmat=ColumnMap[InverseDCT[PadRight[HalfFirst[#],g//Length]]&,mat];

IFun[#,UnitInterval]&/@(Join[{Table[LeftSingularityDataBasis[+1,UnitInterval,k]//First,{k,n}]},-2/(I \[Pi])ArcTanh[IntervalToBottomCircle[g//Points//Rest//Most]] ColumnMap[(#//InverseDCT//Rest//Most)&,IdentityMatrix[{Length[g],n}]]+ColumnMap[(#//Rest//Most)&,dctmat]/(2 I \[Pi]),
{Table[RightSingularityDataBasis[+1,UnitInterval,k]//First,{k,n}]}
]//Transpose)];

FPCauchyBasis[-1,UnitInterval,1;;n_Integer,g_IFun?UnitIntervalFunQ]:=Module[{mat,dctmat,j,k},
mat=ToeplitzMatrix[ZeroVector[n],
4 Riffle[Table[1/j,{j,1,n-1,2}],0]//(Join[{0},If[OddQ[n],Join[#,{0}],#]]&)];
dctmat=ColumnMap[InverseDCT[PadRight[HalfFirst[#],g//Length]]&,mat];

IFun[#,UnitInterval]&/@(Join[{Table[LeftSingularityDataBasis[-1,UnitInterval,k]//First,{k,n}]},-2/(I \[Pi])ArcTanh[IntervalToTopCircle[g//Points//Rest//Most]] ColumnMap[(#//InverseDCT//Rest//Most)&,IdentityMatrix[{Length[g],n}]]+ColumnMap[(#//Rest//Most)&,dctmat]/(2 I \[Pi]),
{Table[RightSingularityDataBasis[-1,UnitInterval,k]//First,{k,n}]}
]//Transpose)];


FPCauchyBasis[s_?SignQ,f:Curve[_IFun],1;;k_Integer,g_IFun]/;f~NEqual~Domain[g]:=Module[{lD,rD,pts,vals,\[Psi]B},
{lD,rD}=MapToIntervalD[f,{f//LeftEndpoint,f//RightEndpoint}];
pts=Function[pt,Select[pt,(!DomainMemberQ[UnitInterval,#])&]]/@ComplexMapToInterval[f,Points[g]];


IFun[#,g//Domain]&/@((Values/@FPCauchyBasis[s,UnitInterval,;;k,g//ToUnitInterval])+MatrixMap[Total,CauchyBasis[UnitInterval,;;k,pts]] +
Array[RightSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[rD]] BasisVector[Length[g]][-1]+LeftSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[lD]] BasisVector[Length[g]][1]&,k])
];


FPCauchyBasis[s_?SignQ,f:Curve[cf_IFun,Stretch->L_],1;;k_Integer,g_IFun]/;f~NEqual~Domain[g]:=Module[{lD,rD,pts,vals,\[Psi]B},
{lD,rD}=MapToIntervalD[f,{f//LeftEndpoint,f//RightEndpoint}];
pts=Function[pt,Select[pt,(!DomainMemberQ[UnitInterval,#])&]]/@ComplexMapToInterval[f,Points[g]];


IFun[#,g//Domain]&/@((Values/@FPCauchyBasis[s,UnitInterval,;;k,g//ToUnitInterval])+MatrixMap[Total,CauchyBasis[UnitInterval,;;k,pts]] +
Array[RightSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[rD]] BasisVector[Length[g]][-1]+LeftSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[lD]] BasisVector[Length[g]][1]&,k]-((cf//Length)-1)CauchyBasis[UnitInterval,;;k,MapToInterval[Line[{-1,1},Stretch->L],\[Infinity]]])
];


(** TODO: Works because RightENdpointInfinityQ returns false for real line.  This should be made consistent **)

FPCauchyBasis[s_?SignQ,f_?RightEndpointInfinityQ,1;;k_Integer,g_IFun]/;f~NEqual~Domain[g]:=IFun[#,g//Domain]&/@((Values/@FPCauchyBasis[s,UnitInterval,1;;k,g//ToUnitInterval])//Function[mat,mat-Array[mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,1.]+\[Mu][#-2,1.])-LeftSingularityDataBasis[UnitInterval,#][[2]] Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]] BasisVector[Length[g]][1]&,k]]);

FPCauchyBasis[s_?SignQ,f_?LeftEndpointInfinityQ,1;;k_Integer,g_IFun]/;f~NEqual~Domain[g]:=IFun[#,g//Domain]&/@((Values/@FPCauchyBasis[s,UnitInterval,1;;k,g//ToUnitInterval])//Function[mat,mat+Array[(-1)^(#)(mat[[1]]+1/(I \[Pi]) (\[Mu][#-1,-1.]+\[Mu][#-2,-1.]))+RightSingularityDataBasis[UnitInterval,#][[2]] Log[Abs[MapToIntervalD[f,f//RightEndpoint]]] BasisVector[Length[g]][-1]&,k]]);


FPCauchyBasis[s_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun]/;f~NEqual~Domain[g]:=IFun[#,g//Domain]&/@((Values/@FPCauchyBasis[s,UnitInterval,;;k,g//ToUnitInterval])-CauchyBasis[UnitInterval,;;k,MapToInterval[f,\[Infinity]]]+
Array[RightSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[MapToIntervalD[f,f//RightEndpoint]]] BasisVector[Length[g]][-1]+LeftSingularityDataBasis[UnitInterval,#][[2]]Log[Abs[MapToIntervalD[f,f//LeftEndpoint]]] BasisVector[Length[g]][1]&,k]);



FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!RightEndpointInfinityQ[#]&&!LeftEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]&&RightEndpoint[f]~NEqual~RightEndpoint[g]:=IFun[#,g//Domain]&/@Transpose[Join[
{First/@LeftSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Most//Rest]],
{First/@RightSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];

FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!RightEndpointInfinityQ[#]&&!LeftEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]&&RightEndpoint[f]~NEqual~LeftEndpoint[g]:=IFun[#,g//Domain]&/@Transpose[Join[
{First/@RightSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Most//Rest]],
{First/@LeftSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];



FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?RightEndpointInfinityQ]/;RightEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[{First/@RightSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest//Most]],
{ZeroVector[k]}]];

FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?LeftEndpointInfinityQ]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
{ZeroVector[k]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest//Most]],
{First/@LeftSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];

FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?LeftEndpointInfinityQ]/;RightEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
{ZeroVector[k]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest//Most]],
{First/@RightSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];
FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?RightEndpointInfinityQ]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[{First/@LeftSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest//Most]],
{ZeroVector[k]}]];




FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!RightEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;RightEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
Transpose[CauchyBasis[f,;;k,g//Points//Most]],
{First/@RightSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];

FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!RightEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;RightEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
{First/@RightSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest]]
]];
FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!LeftEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~RightEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
Transpose[CauchyBasis[f,;;k,g//Points//Most]],
{First/@LeftSingularityDataBasis[f,;;k,RightContourArg[g]]}
]];
FPCauchyBasis[_?SignQ,f_?(IntervalDomainQ[#]&&!LeftEndpointInfinityQ[#]&),1;;k_Integer,g_IFun]/;LeftEndpoint[f]~NEqual~LeftEndpoint[g]:=
IFun[#,g//Domain]&/@Transpose[Join[
{First/@LeftSingularityDataBasis[f,;;k,LeftContourArg[g]]},
Transpose[CauchyBasis[f,;;k,g//Points//Rest]]
]];



FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?LeftEndpointInfinityQ]:=ZeroAtInfinityIFun[#,Domain[g]]&/@CauchyBasis[f,1;;k,g//Points//Rest];
FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun?RightEndpointInfinityQ]:=ZeroAtInfinityIFun[#,Domain[g]]&/@CauchyBasis[f,1;;k,g//Points//Most];
FPCauchyBasis[_?SignQ,f_?IntervalDomainQ,1;;k_Integer,g_IFun]:=IFun[#,Domain[g]]&/@CauchyBasis[f,;;k,g//Points];


\[Psi]pLD[0;;m_?Positive,x_]:=Module[{cur,ph},
ph=\[Psi]pL[0;;m,x];
Join[{cur=\[Psi]pD[0,x]},
Table[cur=cur x+ph[[i]],{i,m}]
]];
\[Psi]pLD[l_?Negative;;m_?Negative,x_]:=Module[{cur,ph},
ph=\[Psi]pL[l;;m,x];
Join[{cur=\[Psi]pD[l,x]},
Table[cur=cur x+ph[[i-l]],{i,l+1,m}]
]];
\[Psi]pLD[i_?Negative;;0,x_]:=Join[\[Psi]pLD[i;;-1,x],{\[Psi]pD[0,x]}];
\[Psi]pLD[i_?Negative;;j_?Positive,x_]:=Join[\[Psi]pLD[i;;-1,x],\[Psi]pLD[0;;j,x]];

CauchyBasisD[UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])IntervalToInnerCircle'[x](\[Psi]pLD[i-1;;k-1,IntervalToInnerCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToInnerCircle[x]]]);
CauchyBasisD[+1,UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])IntervalToBottomCircle'[x](\[Psi]pLD[i-1;;k-1,IntervalToBottomCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToBottomCircle[x]]]);
CauchyBasisD[-1,UnitInterval,i_;;k_,x_]:=
-1/(I \[Pi])IntervalToTopCircle'[x](\[Psi]pLD[i-1;;k-1,IntervalToTopCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToTopCircle[x]]]);

CauchyBasisD[UnitInterval,i_;;k_,x_List]:=
-1/(I \[Pi])IntervalToInnerCircle'[x] #&/@(\[Psi]pLD[i-1;;k-1,IntervalToInnerCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToInnerCircle[x]]]);
CauchyBasisD[+1,UnitInterval,i_;;k_,x_List]:=
-1/(I \[Pi])IntervalToBottomCircle'[x]#&/@(\[Psi]pLD[i-1;;k-1,IntervalToBottomCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToBottomCircle[x]]]);
CauchyBasisD[-1,UnitInterval,i_;;k_,x_List]:=
-1/(I \[Pi])IntervalToTopCircle'[x]#&/@(\[Psi]pLD[i-1;;k-1,IntervalToTopCircle[x]]+Reverse[\[Psi]pLD[-k+1;;1-i,IntervalToTopCircle[x]]]);

CauchyBasisD[f_?RightEndpointInfinityQ,1;;k_,z_]:=MapToIntervalD[f,z]CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];
CauchyBasisD[f_?LeftEndpointInfinityQ,1;;k_,z_]:=MapToIntervalD[f,z]CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];


CauchyBasisD[f_?IntervalDomainQ,1;;k_,z_]:=MapToIntervalD[f,z] CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];

CauchyBasisD[s_,f_?IntervalDomainQ,1;;k_,z_]:=MapToIntervalD[f,z] CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];


CauchyBasisD[s_,f_?RightEndpointInfinityQ,1;;k_,z_]:=MapToIntervalD[f,z]CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];
CauchyBasisD[s_,f_?LeftEndpointInfinityQ,1;;k_,z_]:=MapToIntervalD[f,z]CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];


CauchyBasisD[f_?RightEndpointInfinityQ,1;;k_,z_List]:=MapToIntervalD[f,z]#&/@CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];
CauchyBasisD[f_?LeftEndpointInfinityQ,1;;k_,z_List]:=
MapToIntervalD[f,z]#&/@CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];


CauchyBasisD[f_?IntervalDomainQ,1;;k_,z_List]:=MapToIntervalD[f,z] #&/@CauchyBasisD[UnitInterval,1;;k,MapToInterval[f,z]];
CauchyBasisD[s_,f_?IntervalDomainQ,1;;k_,z_List]:=MapToIntervalD[f,z] #&/@CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];


CauchyBasisD[s_,f_?RightEndpointInfinityQ,1;;k_,z_List]:=MapToIntervalD[f,z]#&/@CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];
CauchyBasisD[s_,f_?LeftEndpointInfinityQ,1;;k_,z_List]:=MapToIntervalD[f,z]#&/@CauchyBasisD[s,UnitInterval,1;;k,MapToInterval[f,z]];




Cauchy[f_IFun,_?InfinityQ]:=0 First[f];
Cauchy[f_List,_?InfinityQ]:=0 First[First[f]];Cauchy[f_IFun,x_]/;(LeftEndpoint[f]~NEqual~x&&Norm[First[f]]~NEqual~0.):=f//LeftSingularityData//First;
Cauchy[_?SignQ,f_IFun,x_]/;(LeftEndpoint[f]~NEqual~x&&Norm[First[f]]~NEqual~0.):=f//LeftSingularityData//First;

Cauchy[f_IFun,x_]/;(LeftEndpoint[f]~NEqual~x):=\[Infinity];
Cauchy[_?SignQ,f_IFun,x_]/;(LeftEndpoint[f]~NEqual~x):=\[Infinity];


Cauchy[f_IFun,x_]/;(RightEndpoint[f]~NEqual~x&&Norm[Last[f]]~NEqual~0.):=f//RightSingularityData//First;
Cauchy[_?SignQ,f_IFun,x_]/;(RightEndpoint[f]~NEqual~x&&Norm[First[f]]~NEqual~0.):=f//RightSingularityData//First;

Cauchy[f_IFun,x_]/;(RightEndpoint[f]~NEqual~x):=\[Infinity];
Cauchy[_?SignQ,f_IFun,x_]/;(RightEndpoint[f]~NEqual~x):=\[Infinity];

Cauchy[f_IFun,x_]:=CauchyBasis[f,;;Length[f],x].(f//DCT);
Cauchy[s_,f_IFun,x_]:=CauchyBasis[s,f,;;Length[f],x].(f//DCT);


Cauchy[f_IFun,xv_List]:=Plus@@(Map[Function[x,x #[[2]]],#[[1]]]&/@Thread[{CauchyBasis[f,;;Length[f],xv],DCT[f]}]);
Cauchy[s_,f_IFun,xv_List]:=Plus@@(Map[Function[x,x #[[2]]],#[[1]]]&/@Thread[{CauchyBasis[s,f,;;Length[f],xv],DCT[f]}]);



Cauchy[f_List,x_]:=Plus@@(Cauchy[#,x]&/@f);


Cauchy[s_,f_List,x_]:=
Plus@@(If[DomainMemberQ[#,x],Cauchy[s,#,x],Cauchy[#,x]]&/@f);
Cauchy[s_,f_List,x_List]:=
Plus@@(Function[U,
Flatten[
If[DomainMemberQ[U,#//First],Cauchy[s,U,#],Cauchy[U,#]]&/@SplitBy[x,DomainMemberQ[U,#]&]
,1]
]/@f);


Hilbert[lf_,z_]:=I (Cauchy[+1,lf,z]+Cauchy[-1,lf,z]);
Hilbert[lf_]:=I (Cauchy[+1,lf]+Cauchy[-1,lf]);

RiemannHilbert`FPCauchy[s_?SignQ,f_IFun,g_IFun]:=IFun[Transpose[(Values/@FPCauchyBasis[s,f,;;Length[f],g])].DCT[f],g//Domain];
FPCauchy[s_?SignQ,f_List,g_IFun]:=FastPlus@@(FPCauchy[s,#,g]&/@f);
FPCauchy[s_?SignQ,f_List,g:{__IFun}]:=FPCauchy[s,f,#]&/@g;
FPCauchy[s_?SignQ,f_]:=FPCauchy[s,f,f];


CauchyBoundedQ[l_List]:=((Function[x,
Plus@@(Which[
LeftEndpoint[#]~NEqual~x,
First[#],
RightEndpoint[#]~NEqual~x,
-Last[#],
True,
0 First[#]]&/@l)]/@Select[Union@@({LeftEndpoint[#],RightEndpoint[#]}&/@l),!InfinityQ[#]&])//Abs//Max)/10//NZeroQ;


Cauchy[s_,f_List?CauchyBoundedQ,g:{__IFun}]:=FPCauchy[s,f,g];
Cauchy[s_,f_List]:=Cauchy[s,f,f];

CauchyOperator[s_,f_List]:=Module[{mat},
mat=CauchyMatrix[s,f];
FromValueList[#,mat.ToValueList[#]]&
];
AddIdentityMatrix[l_IFun]:=(IdentityMatrix[2]+#)&/@l;
AddIdentityMatrix[l_List]:=AddIdentityMatrix/@l;



RiemannHilbert`CauchyD[f_IFun,_?InfinityQ]:=0 First[f];



CauchyD[f_IFun,xv_List]:=Plus@@(Map[Function[x,x #[[2]]],#[[1]]]&/@Thread[{CauchyBasisD[f,;;Length[f],xv],DCT[f]}]);
CauchyD[s_,f_IFun,xv_List]:=Plus@@(Map[Function[x,x #[[2]]],#[[1]]]&/@Thread[{CauchyBasisD[s,f,;;Length[f],xv],DCT[f]}]);


CauchyD[f_List,_?InfinityQ]:=0 First[First[f]];

CauchyD[f_IFun,x_]:=CauchyBasisD[f,;;Length[f],x].(f//DCT);
CauchyD[s_,f_IFun,x_]:=CauchyBasisD[s,f,;;Length[f],x].(f//DCT);



CauchyD[f_List,x_]:=Plus@@(CauchyD[#,x]&/@f);


CauchyD[s_,f_List,x_]:=
Plus@@(If[DomainMemberQ[#,x],CauchyD[s,#,x],CauchyD[#,x]]&/@f);


CauchyD[s_,f_List,x_List]:=
Plus@@(Function[U,
Flatten[
If[DomainMemberQ[U,#//First],CauchyD[s,U,#],CauchyD[U,#]]&/@SplitBy[x,DomainMemberQ[U,#]&]
,1]
]/@f);


CauchyMatrix[s_?SignQ,f_IFun?ScalarFunQ,g_IFun]:=Transpose[(FiniteValues/@FPCauchyBasis[s,f,;;Length[f],g])].FiniteTransformMatrix[f];

ScalarToVectorMatrix:=BlockDiagonalMatrix[{#,#}]&;
ScalarToMatrixMatrix:=BlockDiagonalMatrix[{#,#,#,#}]&;

CauchyMatrix[s_?SignQ,f_IFun?VectorFunQ,g_IFun]:=CauchyMatrix[s,f[[1]],g]//ScalarToVectorMatrix;
CauchyMatrix[s_?SignQ,f_IFun?MatrixFunQ,g_IFun]:=CauchyMatrix[s,f[[1,1]],g]//ScalarToMatrixMatrix;

CauchyMatrix[s_?SignQ,l:{__?MatrixFunQ},g_IFun]:=CauchyMatrix[s,#[[1,1]]&/@l,g]//ScalarToMatrixMatrix;
CauchyMatrix[s_?SignQ,l:{__?MatrixFunQ},l2_List]:=CauchyMatrix[s,#[[1,1]]&/@l,l2]//ScalarToMatrixMatrix;

CauchyMatrix[s_?SignQ,l:{__?VectorFunQ},g_IFun]:=CauchyMatrix[s,#[[1]]&/@l,g]//ScalarToVectorMatrix;
CauchyMatrix[s_?SignQ,l:{__?VectorFunQ},l2_List]:=CauchyMatrix[s,#[[1]]&/@l,l2]//ScalarToVectorMatrix;
CauchyMatrix[s_?SignQ,l:{__IFun},g_IFun]:=RightJoin@@(CauchyMatrix[s,#,g]&/@l);
CauchyMatrix[s_?SignQ,l:{__IFun},l2:{__IFun}]:=Join@@(CauchyMatrix[s,l,#]&/@l2);

CauchyMatrix[s_?SignQ,f_IFun]:=CauchyMatrix[s,f,f];
CauchyMatrix[s_?SignQ,f:{__IFun}]:=CauchyMatrix[s,f,f];




MakeMachineNumber[x_]:=Chop[x,$MinMachineNumber]//N;
RHSolverTop[GGIn:{__IFun},opts:OptionsPattern[] ]:=
RHSolverTop[CauchyMatrix[-1,#[[1,1]]&/@GGIn]//MakeMachineNumber,opts];
RHSolverTop[matmS_,opts:OptionsPattern[{SowCondition->False}]][GG_,GR:{__List}]:=Module[{matt,solv,sol,cond,matm},
matm=matmS//ScalarToVectorMatrix;
matt =SparseIdentityMatrix[Length[matm]]+(SparseIdentityMatrix[Length[matm]]-MakeMachineNumber[RightMatrixMultVectorFun[GG]]).matm//MakeMachineNumber;
If[OptionValue[SowCondition],
cond=LinearAlgebra`MatrixConditionNumber[matt];
Sow[cond];
];
solv=LinearSolve[matt];
sol=FromValueList[#,solv[#//ToValueList//MakeMachineNumber]]&/@GR
];

RHSolverTop[matm_,opts:OptionsPattern[]][GG_] := RHSolverTop[matm,opts][GG,#[[1,All]]&/@(#-IdentityMatrix[2]&/@#&/@GG)];

RHSolverTop[matm_,opts:OptionsPattern[]][GG_,GR_]:=
RHSolverTop[matm,opts][GG,{GR}]//First;


RHSolveTop[GG_List,GI_List,opts:OptionsPattern[]]:=Module[{matp,matm,GITop},
RHSolverTop[GG,opts][GG,GI]];

RHSolveTop[GG_List,opts:OptionsPattern[]]:=
RHSolveTop[GG,#[[1,All]]&/@(#-IdentityMatrix[2]&/@#&/@GG),opts];


RHSolver[GGIn_List,opts:OptionsPattern[]]:=Module[{rsolvt},
rsolvt=RHSolverTop[GGIn,opts];
RHSolver[rsolvt]
];

RHSolver[rsolvt_RHSolverTop][GG_,GR_] :=ToArrayFun[Join[{ToArrayOfFuns[#[[1]]]},{ToArrayOfFuns[#[[2]]]}]]&/@Thread[rsolvt[GG,{#[[1,All]]&/@GR,#[[2,All]]&/@GR}]];
RHSolver[rsolvt_RHSolverTop][GG_]:=RHSolver[rsolvt][GG,(#-IdentityMatrix[2]&/@#&/@GG)];

RHSolve[GG_List,GI_List,opts:OptionsPattern[]]:=
RHSolver[GG,opts][GG,GI];
RHSolve[GG_List,opts:OptionsPattern[]]:=
RHSolve[GG,#-IdentityMatrix[2]&/@#&/@GG,opts];


FunValueListOperator[mat_,g_][f:{__?ScalarFunQ}]:=FromValueList[g,mat.ToValueList[f]];
FunValueListOperator[mat_,g_][f:{__?VectorFunQ}]:=FromValueList[{0,0}&/@#&/@g,ScalarToVectorMatrix[mat].ToValueList[f]];
FunValueListOperator[mat_,g_][f:{__?MatrixFunQ}]:=FromValueList[({
 {0, 0},
 {0, 0}
})&/@#&/@g,ScalarToMatrixMatrix[mat].ToValueList[f]];

FunValueListOperator[mat_][f_]:=FunValueListOperator[mat,f][f];

SetDomain[op_FunValueListOperator,d_]:=FunValueListOperator[op[[1]],SetDomain[op[[2]],d]];

CauchyOperator[1,R_RHSolverTop]:=
FunValueListOperator[R[[1]]+SparseIdentityMatrix[Length[R[[1]]]]];
CauchyOperator[-1,R_RHSolverTop]:=
FunValueListOperator[R[[1]]];
CauchyOperator[s_,R_RHSolver]:=
CauchyOperator[s,R[[1]]];


RiemannHilbert`CauchyInverse::usage="CauchyInverse[f,z] computes the function \[Phi][z] such that the Cauchy transform of \[Phi]^+";

RiemannHilbert`CauchyInverseBasis[d_,1,z_]:=1/2-MapToInterval[d,z]/(2 Sqrt[MapToInterval[d,z]+1] Sqrt[MapToInterval[d,z]-1]);
CauchyInverseBasis[d_,k_,z_]:=IntervalToInnerCircle[MapToInterval[d,z]]^(k-1)/2;
CauchyInverseBasis[s_,d_,1,z_]:=1/2+s I MapToInterval[d,z]/(2 Sqrt[1-MapToInterval[d,z]^2]);
CauchyInverseBasis[+1,d_,k_,z_]:=IntervalToBottomCircle[MapToInterval[d,z]]^(k-1)/2;
CauchyInverseBasis[-1,d_,k_,z_]:=IntervalToTopCircle[MapToInterval[d,z]]^(k-1)/2;

CauchyInverse[f_IFun?(NZeroQ[Mean[#]]&),z_]:=MapDot[CauchyInverseBasis[f,#+1,z]&,f//DCT//Rest];
CauchyInverse[s_,f_IFun?(NZeroQ[Mean[#]]&),z_]:=MapDot[CauchyInverseBasis[s,f,#+1,z]&,f//DCT//Rest];

CauchyInverse[f_IFun,z_]:=MapDot[CauchyInverseBasis[f,#,z]&,f//DCT];
CauchyInverse[s_,f_IFun,z_]:=MapDot[CauchyInverseBasis[s,f,#,z]&,f//DCT];

BoundedCauchyInverse[f_IFun,z_]:=MapDot[IntervalToInnerCircle[MapToInterval[f,z]]^(#-1)/2&,f//DCT];

RiemannHilbert`CauchyInversePlus[f_IFun,z_]/;DomainMemberQ[f,z]:=f[z];
CauchyInversePlus[f_IFun,z_]:=2 CauchyInverse[f,z];

RiemannHilbert`HilbertInverse[f_IFun,z_]:=-Sqrt[1-MapToInterval[f,z]^2] MapDot[ChebyshevU[#-1,MapToInterval[f,z]]&,f//DCT//Rest];

RiemannHilbert`SPCauchyInverseIntegral[f_IFun?IntervalFunQ]:=1/MapToIntervalD[f,0.] IFun[1/2  ( MapOuter[Which[#==1,0,#==2,2/(#-1),True,1/(#-1)]&,(DCT[f]//GrowShiftRight)]-PadRight[MapOuter[If[#==1,0,1/(#-1)]&,(DCT[f]//GrowShiftLeft)],Length[f]+1])//InverseDCT,Domain[f]];

RiemannHilbert`CauchyInverseIntegral[f_IFun?IntervalFunQ,z_]:=
CauchyInverse[SPCauchyInverseIntegral[f],z]-1/(4 MapToIntervalD[f,0.]) DCT[f][[2]]Log[IntervalToInnerCircle[MapToInterval[f,z]]];

RiemannHilbert`CauchyInverseIntegralS[s_?SignQ,f_IFun?IntervalFunQ,z_]:=
CauchyInverse[s,SPCauchyInverseIntegral[f],z]+s ArcCos[MapToInterval[f,z]]1/(4MapToIntervalD[f,0.]) DCT[f][[2]]  I;

CauchyInverseIntegral[s_?SignQ,f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=
CauchyInverse[s,SPCauchyInverseIntegral[f],z]+s ArcCos[MapToInterval[f,z]]1/(4MapToIntervalD[f,0.]) DCT[f][[2]]  I;

CauchyInverseIntegral[s_,f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=
CauchyInverse[SPCauchyInverseIntegral[f],z]-1/(4 MapToIntervalD[f,0.]) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]]-s I \[Pi]);
CauchyInverseIntegral[_,f_IFun?IntervalFunQ,z_]:=CauchyInverseIntegral[f,z];

RiemannHilbert`CauchyInverseIntegralPlus[f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=SPCauchyInverseIntegral[f][z];
CauchyInverseIntegralPlus[f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=CauchyInversePlus[SPCauchyInverseIntegral[f],z]-1/(2 MapToIntervalD[f,0.]) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]]);
CauchyInverseIntegralPlus[f_IFun?IntervalFunQ,z_]:=2 CauchyInverseIntegral[f,z];



CauchyInverseMatrix[s_,f_IFun]:=Transpose[Array[CauchyInverseBasis[s,f,#,Points[f]]&,Length[f]]].TransformMatrix[f];
CauchyInverseMatrix[s_,f_IFun,g_IFun]/;Domain[f]==Domain[g]:=Transpose[Array[CauchyInverseBasis[s,f,#,Points[g]]&,Length[f]]].TransformMatrix[f];
CauchyInverseMatrix[_,f_IFun,g_IFun]:=Transpose[Array[CauchyInverseBasis[f,#,Points[g]]&,Length[f]]].TransformMatrix[f];


CauchyInversePlusMatrix::usage="Returns the matrix corresponding to a list {f,g} f^+ + g^+ + f^- + g^-";
CauchyInversePlusMatrix[l_List]:=Join@@((RightJoin@@#)&/@MatrixMap[If[#[[1]]===#[[2]] ,IdentityMatrix[Length[#[[1]]]],2 CauchyInverseMatrix[+1,#[[2]],#[[1]]]]&,Outer[List,l,l]]);

RiemannHilbert`CauchyInverseCurves[l_List]:=FromValueList[l,LinearSolve[CauchyInversePlusMatrix[l],l//ToValueList]];

CauchyInverse[l_List,z_]:=Plus@@(CauchyInverse[#,z]&/@CauchyInverseCurves[l]);
CauchyInverse[s_,l_List,z_]:=Plus@@(If[DomainMemberQ[#,z],CauchyInverse[s,#,z],CauchyInverse[#,z]]&/@CauchyInverseCurves[l]);

RiemannHilbert`CauchyInverseSeriesAtInfinity[f_IFun]:=DCT[f][[2]]/(4 MapToIntervalSeriesAtInfinity[f,1]);
CauchyInverseSeriesAtInfinity[l_List]:=Plus@@(CauchyInverseSeriesAtInfinity[#]&/@CauchyInverseCurves[l]);




CauchyInverseIntegral[l_List,z_]:=Plus@@(CauchyInverseIntegral[#,z]&/@CauchyInverseCurves[l]);
CauchyInverseIntegral[s_?SignQ,l_List,z_]:=Plus@@(CauchyInverseIntegral[s,#,z]&/@CauchyInverseCurves[l]);

CauchyInverseIntegralPlus[l_,z_]:=Plus@@(CauchyInverseIntegralPlus[#,z]&/@CauchyInverseCurves[l]);



RiemannHilbert`CauchyInverseBasisD[d_,1,z_]:=MapToIntervalD[d,z]/(2 (-1+MapToInterval[d,z])^(3/2) (1+MapToInterval[d,z])^(3/2));
CauchyInverseBasisD[s_,d_,1,z_]:=-I s MapToIntervalD[d,z]/(2 Sqrt[1-MapToInterval[d,z]^2] (MapToInterval[d,z]^2-1));


CauchyInverseBasisD[d_,k_,z_]:=(k-1)IntervalToInnerCircle[MapToInterval[d,z]]^(k-2)/2IntervalToInnerCircle'[MapToInterval[d,z]] MapToIntervalD[d,z];


CauchyInverseBasisD[+1,d_,k_,z_]:=(k-1)IntervalToBottomCircle[MapToInterval[d,z]]^(k-2)/2IntervalToBottomCircle'[MapToInterval[d,z]] MapToIntervalD[d,z];
CauchyInverseBasisD[-1,d_,k_,z_]:=(k-1)IntervalToTopCircle[MapToInterval[d,z]]^(k-2)/2IntervalToTopCircle'[MapToInterval[d,z]] MapToIntervalD[d,z];



RiemannHilbert`CauchyInverseBasisDomainD[spc__][d_,1,z_]:=MapToIntervalDomainD[spc][d,z]/(2 (-1+MapToInterval[d,z])^(3/2) (1+MapToInterval[d,z])^(3/2));
CauchyInverseBasisDomainD[spc__][s_,d_,1,z_]:=-I s MapToIntervalDomainD[spc][d,z]/(2 Sqrt[1-MapToInterval[d,z]^2] (MapToInterval[d,z]^2-1));


CauchyInverseBasisDomainD[spc__][d_,k_,z_]:=(k-1)IntervalToInnerCircle[MapToInterval[d,z]]^(k-2)/2IntervalToInnerCircle'[MapToInterval[d,z]] MapToIntervalDomainD[spc][d,z];


CauchyInverseBasisDomainD[spc__][+1,d_,k_,z_]:=(k-1)IntervalToBottomCircle[MapToInterval[d,z]]^(k-2)/2IntervalToBottomCircle'[MapToInterval[d,z]] MapToIntervalDomainD[spc][d,z];
CauchyInverseBasisDomainD[spc__][-1,d_,k_,z_]:=(k-1)IntervalToTopCircle[MapToInterval[d,z]]^(k-2)/2IntervalToTopCircle'[MapToInterval[d,z]] MapToIntervalDomainD[spc][d,z];








CauchyInverseMatrixD[{spc__},{0,0}][_,f_IFun,g_IFun]:=Transpose[Array[CauchyInverseBasisDomainD[spc][f,#,Points[g]]&,Length[f]]].TransformMatrix[f];
CauchyInverseMatrixD[{0,0},{spc__}][_,f_IFun,g_IFun]:=Transpose[Array[CauchyInverseBasisD[f,#,Points[g]]PointsD[spc][g]&,Length[f]]].TransformMatrix[f];


CauchyInversePlusMatrixD[spca__][fl_List]:=Join@@((RightJoin@@#)&/@MatrixMap[Which[#[[1]]===#[[2]] ,
ZeroMatrix[Length[#[[1,1]]]],
#[[1,2]]==#[[2,2]]=={0,0},
ZeroMatrix[Length[#[[1,1]]],Length[#[[2,1]]]],
True,
2 CauchyInverseMatrixD[#[[2,2]],#[[1,2]]][+1,#[[2,1]],#[[1,1]]]
]&,Outer[List,Thread[{fl,{spca}}],Thread[{fl,{spca}}],1]]);

RiemannHilbert`CauchyInverseCurvesD[spc__][l_List]:=Module[{plusmatin},
plusmatin=CauchyInversePlusMatrix[l]//Inverse;

FromValueList[l,
-plusmatin.CauchyInversePlusMatrixD[spc][l].plusmatin.(l//ToValueList)+plusmatin.ToValueListD[spc][l]
]];







CauchyInverseDomainGrad[spc__][f_IFun,z_]:=MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,f//DCT];
CauchyInverseDomainGrad[spc__][s_,f_IFun,z_]:=MapDot[CauchyInverseBasisDomainD[spc][s,f,#,z]&,f//DCT];


CauchyInverseDomainD[spc__][f_IFun,z_]:=CauchyInverseDomainGrad[spc][f,z]+MapDot[CauchyInverseBasis[f,#,z]&,ValuesDomainD[spc][f]//DCT];
CauchyInverseDomainD[spc__][s_,f_IFun,z_]:=CauchyInverseDomainGrad[spc][s,f,z]+MapDot[CauchyInverseBasis[s,f,#,z]&,ValuesDomainD[spc][f]//DCT];


RiemannHilbert`CauchyInverseSeriesAtInfinityDomainD[spc__][f_IFun]:=DCT[ValuesDomainD[spc][f]][[2]]/(4 MapToIntervalSeriesAtInfinity[f,1])-(DCT[f][[2]] MapToIntervalSeriesAtInfinityD[spc][f,1])/(4 MapToIntervalSeriesAtInfinity[f,1]^2);

CauchyInverseSeriesAtInfinityValuesD[f_IFun]:=TransformMatrix[f][[2,All]]/(4 MapToIntervalSeriesAtInfinity[f,1]);


RiemannHilbert`CauchyInverseSeriesAtInfinityD[spc__][fl_List]:=Plus@@((DCT[#][[2]]/(4 MapToIntervalSeriesAtInfinity[#,1])&/@CauchyInverseCurvesD[spc][fl])-(If[#[[2]]=={0,0},0,DCT[#[[1]]][[2]]MapToIntervalSeriesAtInfinityD[Sequence@@#[[2]]][#[[1]],1]/(4 MapToIntervalSeriesAtInfinity[#[[1]],1]^2)]&/@Thread[{CauchyInverseCurves[fl],{spc}}]));



RiemannHilbert`SPCauchyInverseIntegralDomainGrad[spc__][f_]:=-(MapToIntervalDDomainD[spc][f,0.]/MapToIntervalD[f,0.]^2)IFun[1/2  ( MapOuter[Which[#==1,0,#==2,2/(#-1),True,1/(#-1)]&,(DCT[f]//ShiftRight)]-MapOuter[If[#==1,0,1/(#-1)]&,(DCT[f]//GrowShiftLeft)])//InverseDCT,Domain[f]];

SPCauchyInverseIntegralDomainD[spc__][f_]:=SPCauchyInverseIntegralDomainGrad[spc][f]+1/MapToIntervalD[f,0.] IFun[1/2  ( MapOuter[Which[#==1,0,#==2,2/(#-1),True,1/(#-1)]&,(DCT[ValuesDomainD[spc][f]]//ShiftRight)]-MapOuter[If[#==1,0,1/(#-1)]&,(DCT[ValuesDomainD[spc][f]]//GrowShiftLeft)])//InverseDCT,Domain[f]];

SPCauchyInverseIntegralValuesD[f_IFun?IntervalFunQ]:=1/MapToIntervalD[f,0.] Inverse[TransformMatrix[f]].ColumnMap[1/2 MapOuter[Which[#==1,0,#==2,2/(#-1),True,1/(#-1)]&,(#//ShiftRight)]-MapOuter[If[#==1,0,1/(#-1)]&,(#//GrowShiftLeft)]&,IdentityMatrix[f//Length]].TransformMatrix[f];

CauchyInverseIntegralDomainGrad[spc__][f_IFun?IntervalFunQ,z_]:=MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[f,#,z]&,SPCauchyInverseIntegralDomainGrad[spc][f]//DCT]-(-MapToIntervalDDomainD[spc][f,0.]/(4 MapToIntervalD[f,0.]^2) DCT[f][[2]]Log[IntervalToInnerCircle[MapToInterval[f,z]]]+1/(4 MapToIntervalD[f,0.]) DCT[f][[2]]IntervalToInnerCircle'[MapToInterval[f,z]]MapToIntervalDomainD[spc][f,z]/IntervalToInnerCircle[MapToInterval[f,z]]);

CauchyInverseIntegralDomainD[spc__][f_IFun?IntervalFunQ,z_]:=MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[f,#,z]&,SPCauchyInverseIntegralDomainD[spc][f]//DCT]-(-MapToIntervalDDomainD[spc][f,0.]/(4 MapToIntervalD[f,0.]^2) DCT[f][[2]]Log[IntervalToInnerCircle[MapToInterval[f,z]]]+1/(4 MapToIntervalD[f,0.]) DCT[ValuesDomainD[spc][f]][[2]]Log[IntervalToInnerCircle[MapToInterval[f,z]]]+1/(4 MapToIntervalD[f,0.]) DCT[f][[2]]IntervalToInnerCircle'[MapToInterval[f,z]]MapToIntervalDomainD[spc][f,z]/IntervalToInnerCircle[MapToInterval[f,z]]);

CauchyInverseIntegralDomainD[spc__][s_?SignQ,f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=
MapDot[CauchyInverseBasisDomainD[spc][s,f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[s,f,#,z]&,SPCauchyInverseIntegralDomainD[spc][f]//DCT]+s ArcCos'[MapToInterval[f,z]] MapToIntervalDomainD[spc][f,z]1/(4MapToIntervalD[f,0.]) DCT[f][[2]]  I-s ArcCos[MapToInterval[f,z]]MapToIntervalDDomainD[spc][f,0.]/(4MapToIntervalD[f,0.]^2) DCT[f][[2]]  I+s ArcCos[MapToInterval[f,z]]1/(4MapToIntervalD[f,0.]) DCT[ValuesDomainD[spc][f]][[2]]  I;

CauchyInverseIntegralDomainD[spc__][s_,f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=
MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[f,#,z]&,SPCauchyInverseIntegralDomainD[spc][f]//DCT]-(-MapToIntervalDDomainD[spc][f,0.]/(4 MapToIntervalD[f,0.]^2) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]]-s I \[Pi])+1/(4 MapToIntervalD[f,0.]) DCT[ValuesDomainD[spc][f]][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]]-s I \[Pi])+1/(4 MapToIntervalD[f,0.]) DCT[f][[2]](IntervalToInnerCircle'[MapToInterval[f,z]]MapToIntervalDomainD[spc][f,z]/(IntervalToInnerCircle[MapToInterval[f,z]])));

CauchyInverseIntegralDomainD[spc__][_,f_IFun?IntervalFunQ,z_]:=CauchyInverseIntegralDomainD[spc][f,z];


RiemannHilbert`CauchyInverseIntegralPlusDomainGrad[spc__][f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=SPCauchyInverseIntegralDomainGrad[spc][f][z];

CauchyInverseIntegralPlusDomainGrad[spc__][f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=2(MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[f,#,z]&,SPCauchyInverseIntegralDomainGrad[spc][f]//DCT])-(
-MapToIntervalDDomainD[spc][f,0.]/(2 MapToIntervalD[f,0.]^2) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]])+1/(2 MapToIntervalD[f,0.]) DCT[f][[2]](IntervalToInnerCircle'[MapToInterval[f,z]] MapToIntervalDomainD[spc][f,z]/IntervalToInnerCircle[MapToInterval[f,z]])
);

CauchyInverseIntegralPlusDomainGrad[spc__][f_IFun?IntervalFunQ,z_]:=2 CauchyInverseIntegralDomainGrad[spc][f,z];


CauchyInverseIntegralPlus[f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=CauchyInversePlus[SPCauchyInverseIntegral[f],z]-1/(2 MapToIntervalD[f,0.]) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]]);
CauchyInverseIntegralPlus[f_IFun?IntervalFunQ,z_]:=2 CauchyInverseIntegral[f,z];


RiemannHilbert`CauchyInverseIntegralPlusDomainD[spc__][f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=CauchyInverseIntegralPlusDomainGrad[spc][f,z]+BaryDomainD[spc][SPCauchyInverseIntegral[f],z];


CauchyInverseIntegralPlusDomainD[spc__][f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=2(MapDot[CauchyInverseBasisDomainD[spc][f,#,z]&,SPCauchyInverseIntegral[f]//DCT]+MapDot[CauchyInverseBasis[f,#,z]&,SPCauchyInverseIntegralDomainD[spc][f]//DCT])-(
-MapToIntervalDDomainD[spc][f,0.]/(2 MapToIntervalD[f,0.]^2) DCT[f][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]])+1/(2 MapToIntervalD[f,0.]) DCT[ValuesDomainD[spc][f]][[2]](Log[Abs[IntervalToInnerCircle[MapToInterval[f,z]]]])+1/(2 MapToIntervalD[f,0.]) DCT[f][[2]](IntervalToInnerCircle'[MapToInterval[f,z]] MapToIntervalDomainD[spc][f,z]/IntervalToInnerCircle[MapToInterval[f,z]])
);
CauchyInverseIntegralPlusDomainD[spc__][f_IFun?IntervalFunQ,z_]:=2 CauchyInverseIntegralDomainD[spc][f,z];



CauchyInverseD[f_IFun,z_]:=MapDot[CauchyInverseBasisD[f,#,z]&,f//DCT];
CauchyInverseD[s_,f_IFun,z_]:=MapDot[CauchyInverseBasisD[s,f,#,z]&,f//DCT];
CauchyInversePlusD[f_IFun,z_]:=2 CauchyInverseD[f,z];
CauchyInversePlusD[f_IFun,z_]/;DomainMemberQ[f,z]:=f'[z];


CauchyInverseIntegralD[f_IFun?IntervalFunQ,z_]:=
CauchyInverseD[SPCauchyInverseIntegral[f],z]-1/(4 MapToIntervalD[f,0.]) DCT[f][[2]]IntervalToInnerCircle'[MapToInterval[f,z]]MapToIntervalD[f,z]/IntervalToInnerCircle[MapToInterval[f,z]];


RiemannHilbert`CauchyInverseIntegralPlusD[f_IFun?IntervalFunQ,z_]/;DomainMemberQ[f,z]:=SPCauchyInverseIntegral[f]'[z];
CauchyInverseIntegralPlusD[f_IFun?IntervalFunQ,z_]/;NZeroQ[Im[z]]&&Re[z]<=LeftEndpoint[f]:=CauchyInversePlusD[SPCauchyInverseIntegral[f],z]-1/(2 MapToIntervalD[f,0.]) DCT[f][[2]](IntervalToInnerCircle'[MapToInterval[f,z]]MapToIntervalD[f,z]/IntervalToInnerCircle[MapToInterval[f,z]]);
CauchyInverseIntegralPlusD[f_IFun?IntervalFunQ,z_]:=2 CauchyInverseIntegralD[f,z];


CauchyInverseIntegralPlusD[l_List,z_]:=Plus@@(CauchyInverseIntegralPlusD[#,z]&/@CauchyInverseCurves[l]);


CauchyInverseIntegralPlusDomainD[spc__][fl_List,z_]:=Plus@@(
Which[
DomainMemberQ[#[[1]],z]&&#[[3]]=={0,0},
SPCauchyInverseIntegral[#[[2]]][z],
DomainMemberQ[#[[1]],z],
SPCauchyInverseIntegralDomainGrad[Sequence@@#[[3]]][#[[1]]][z]+SPCauchyInverseIntegral[#[[2]]][z]+BaryDomainD[Sequence@@#[[3]]][SPCauchyInverseIntegral[#[[1]]],z],
#[[3]]=={0,0},
CauchyInverseIntegralPlus[#[[2]],z],
True,
CauchyInverseIntegralPlusDomainGrad[Sequence@@#[[3]]][#[[1]],z]+CauchyInverseIntegralPlus[#[[2]],z]
]&/@Thread[{CauchyInverseCurves[fl],CauchyInverseCurvesD[spc][fl],{spc}}]
);





RiemannHilbert`FredholmDet[K_,a_,b_,m_]:=
Module[{w,x},
{x,w}=GaussianQuadratureWeights[m,a,b]//Thread;
w=Sqrt[w];
Det[IdentityMatrix[m]-(Transpose[{w}].{w})Outer[K,x,x]]];
FredholmDet[K_,a_,\[Infinity],m_]:=Module[{Ks,x,w,\[Phi]},
\[Phi][s_][x_]:=s+10 Tan[\[Pi] x/2];
Ks[s_][x_,y_]:=Sqrt[\[Phi][s]'[x]\[Phi][s]'[y]] K[\[Phi][s][x],\[Phi][s][y]];
{x,w}=GaussianQuadratureWeights[m,0,1]//Thread;
w=Sqrt[w];
IdentityMatrix[m]-(Transpose[{w}].{w})Outer[Ks[a],x,x]//Det
];


RiemannHilbert`DiagonalMatrixQ[DD_]:=Norm[DD-DiagonalMatrix[Diagonal[DD]]]==0;

RiemannHilbert`Parametrix[DD_?DiagonalMatrixQ,Line[{-1/2,1/2}],z_]:=({
 {((1+2 z)/(2z -1))^(I/(2 \[Pi]) (Log[Abs[DD[[1,1]]]]+ I (Arg[DD[[1,1]]]))), 0},
 {0, ((1+2 z)/(2z -1))^(I/(2 \[Pi]) (Log[Abs[DD[[2,2]]]]+ I( Arg[DD[[2,2]]]//If[#>0,#-2 \[Pi],#]&)))}
});
RiemannHilbert`ParametrixBranch[DD_?DiagonalMatrixQ,Line[{-1/2,1/2}],z_,t_]:=({
 {PowerBranch[(1+2 z)/(2z -1),I/(2 \[Pi]) Log[DD[[1,1]]],t], 0},
 {0, PowerBranch[(1+2 z)/(2z -1),I/(2 \[Pi]) (Log[Abs[DD[[2,2]]]]+ I( Arg[DD[[2,2]]]//If[#>0,#-2 \[Pi],#]&)),t]}
});

RiemannHilbert`ParametrixBranch[({
 {0, 1},
 {-1, 0}
}),Line[{a_,b_}],z_,t_]:=Module[{\[Beta],p},
\[Beta][p_]:=PowerBranch[(z-a)/(z-b),1/4,t];
({
 {(\[Beta][z]+1/\[Beta][z])/2, (\[Beta][z]-1/\[Beta][z])/(2 I)},
 {-((\[Beta][z]-1/\[Beta][z])/(2I)), (\[Beta][z]+1/\[Beta][z])/2}
})];
RiemannHilbert`Parametrix[({
 {0, 1},
 {-1, 0}
}),Line[{a_,b_}],z_]:=Module[{\[Beta],p},
\[Beta][p_]:=((p-b)/(p-a))^(1/4);
({
 {(\[Beta][z]+1/\[Beta][z])/2, (\[Beta][z]-1/\[Beta][z])/(2 I)},
 {-((\[Beta][z]-1/\[Beta][z])/(2I)), (\[Beta][z]+1/\[Beta][z])/2}
})];


RiemannHilbert`RHWellPosed[GG_,Gg_]:=Dot@@(If[LeftEndpoint[#]~NEqual~(Gg),
First[#],
Inverse[Last[#]]]&/@
SelectWithPoint[GG,Gg])//Chop;
RHWellPosed[GG_]:=RHWellPosed[GG,#]&/@Endpoints[GG];
RiemannHilbert`ZeroSumCondition[GG_,Gg_]:=
Plus@@(If[LeftEndpoint[#]~NEqual~(Gg),
First[#],
-Last[#]]&/@
SelectWithPoint[GG,Gg])//Chop;
ZeroSumCondition[GG_]:=ZeroSumCondition[GG,#]&/@Endpoints[GG];



IteratedRHSolver[{{{z0_,sc_},lsGs_},Grest___},{},R_,gms_]:=Module[{Cus,uz0,usc,us,gl},
gl=Fun[Function[z,#[[1]][z0+z/sc]],Sequence@@#[[2]]]&/@Thread[{lsGs,gms}];
IteratedRHSolver[{Grest},{{z0,sc,R[gl]}},R,gms]
];
IteratedRHSolver[{},Uls_,_,_]:=Uls;
IteratedRHSolver[{{{z0_,sc_},lsGs_},Grest___},Uls_,R_,gms_]:=Module[{Cus,uz0,usc,us,gl},
gl=Fun[Function[z,#[[1]][z0+z/sc]],Sequence@@#[[2]]]&/@Thread[{lsGs,gms}];
Cus=(Dot@@#)&/@Thread[
Function[uls,
{uz0,usc,us}=uls;
FromValueList[gl,Cauchy[us,((z0+Points[gl]/sc)-uz0)usc]//ToMatrixOfLists//Flatten]//AddIdentityMatrix
]/@Uls
];
IteratedRHSolver[{Grest},Join[{{z0,sc,R[#[[1]].#[[2]].Inverse[#[[1]]]&/@Thread[{Cus,gl}]]}},Uls],R,gms]
];


OuterIteratedRHSolver[{},Uls_,_]:=Uls;
OuterIteratedRHSolver[{{{scale_,domains_},jumps_,R_},rest___},Uls_,x_]:=OuterIteratedRHSolver[{rest},IteratedRHSolver[Thread[{scale[x]//Transpose,jumps//Transpose}],Uls,R,domains],x];


ConvertIteratedToStandardFunList[ifl_]:=(Function[sfl,IFun[Values[#],((#//Domain)/sfl[[2]]+sfl[[1]])]&/@Last[sfl]]/@ifl);


RiemannHilbert`ScaledRHSolver[l:{{_,_}..}]:=Module[{scale,domains},
ScaledRHSolver[l,
Function[Gl,
{scale,domains}=Gl;
RHSolver[Function[domain,Fun[IdentityMatrix[2]&,Sequence@@domain]]/@domains]
]/@l
]
];
ScaledRHSolver[l:{{_,_}..},Rs_][x_,Gf_]:=OuterIteratedRHSolver[Thread[{l,Gf,Rs}],{},x]//ConvertIteratedToStandardFunList;





ScaledRHSolver[{scs_,gms_}]:=
ScaledRHSolver[{scs,gms},RHSolver[Fun[IdentityMatrix[2]&,Sequence@@##]&/@gms]];
ScaledRHSolver[{scs_,gms_},R_RHSolver][x_,gs_]:=IteratedRHSolver[Thread[{scs[x]//Transpose,gs//Transpose}],{},R,gms]//ConvertIteratedToStandardFunList;


CauchyMatrix[s_,l1:{{_?IntervalDomainQ,_Integer}..},l2:{{_?IntervalDomainQ,_Integer}..}]:=CauchyMatrix[s,IFun[Array[0&,#[[2]]],#[[1]]]&/@l1,IFun[Array[0&,#[[2]]],#[[1]]]&/@l2];
CauchyOperator[s_,l1:{{_?IntervalDomainQ,_Integer}..},l2:{{_?IntervalDomainQ,_Integer}..}]:=FunValueListOperator[CauchyMatrix[s,l1,l2],IFun[Array[0&,#[[2]]],#[[1]]]&/@l2];

(** We want to be able to change the domain after the fact below **)

CauchyOperator[s_,l1:{{_?DomainQ,_Integer}..},l2:{{_?DomainQ,_Integer}..},l3:{{_?DomainQ,_Integer}..}]:=FunValueListOperator[CauchyMatrix[s,l1,l2],IFun[Array[0&,#[[2]]],#[[1]]]&/@l3];


IteratedScaledCauchy[{{z0_,sc_},rest___},{},gms_,i_]:=IteratedScaledCauchy[{rest},{{z0,sc,i,{}}},gms,i];
IteratedScaledCauchy[{{z0_,sc_},rest___},Uls_,gms_,i_]:=Module[{Cmats,uz0,usc,us,ugms,uCmats,uR,uz0scs,ui},
Cmats=Function[ulscs,
{uz0,usc,ui,uCmats}=ulscs;
CauchyOperator[+1,gms[[ui]],{usc (z0+#[[1]]/sc-uz0),#[[2]]}&/@gms[[i]],gms[[ui]]]
]/@Uls;
IteratedScaledCauchy[{rest},Join[Uls,{{z0,sc,i,Cmats}}],gms,i]];
IteratedScaledCauchy[{},Uls_,_,_]:=Uls;
OuterIteratedScaledCauchy[{},Uls_,_,_,_]:=Uls;
OuterIteratedScaledCauchy[{scales_,rest___},Uls_,gms_,i_,x_]:=
OuterIteratedScaledCauchy[{rest},IteratedScaledCauchy[scales[x]//Transpose,Uls,gms,i],gms,i+1,x];



IteratedRHSolver[{},Uls_,_,_]:=Uls;IteratedRHSolver[{{{z0_,sc_,i_,Cmats_},Gf_},Grest___},{},Rs_,gms_]:=Module[{gl},
gl=Fun[Function[z,#[[1]][z0+z/sc]],Sequence@@#[[2]]]&/@Thread[{Gf,gms[[i]]}];
IteratedRHSolver[{Grest},{{z0,sc,Rs[[i]][gl]}},Rs,gms]
];
IteratedRHSolver[{{{z0_,sc_,i_,Cmats_},Gf_},Grest___},Uls_,Rs_,gms_]:=Module[{Cus,uz0,usc,us,gl,Cs},
gl=Fun[Function[z,#[[1]][z0+z/sc]],Sequence@@#[[2]]]&/@Thread[{Gf,gms[[i]]}];
Cus=(Dot@@#)&/@Thread[
Function[uls,
{{uz0,usc,us},Cs}=uls;
Cs[us]//AddIdentityMatrix
]/@Reverse[Thread[{Uls,Cmats}]]
];

IteratedRHSolver[{Grest},Join[Uls,{{z0,sc,Rs[[i]][#[[1]].#[[2]].Inverse[#[[1]]]&/@Thread[{Cus,gl}]]}}],Rs,gms]
];


ScaledRHSolver[l:{{_,_}..},Rs_][x_]:=
ScaledRHSolver[OuterIteratedScaledCauchy[First/@l,{},Last/@l,1,x],Rs,Last/@l];
ScaledRHSolver[l:{{_,_,_,_}..},Rs:{__RHSolver},gms:{{{_?DomainQ,_}..}..}][Gl_]:=
IteratedRHSolver[Thread[{l,Flatten[Transpose/@Gl,1]}],{},Rs,gms]//ConvertIteratedToStandardFunList;
ScaledRHSolver[l:{{_,_,_,_}..},R_RHSolver,gms:{{_?DomainQ,_}..}][Gl_]:=
ScaledRHSolver[l,{R},{gms}][{Gl}];
ScaledRHSolver[{scs_,gms_},R_][x_]:=
ScaledRHSolver[OuterIteratedScaledCauchy[{scs},{},{gms},1,x],R,gms];


(**TODO: ScaledCauchyOperator currently only works with two symmetric scaled graphs **)
(**TODO: ScaledCauchyOperator currently returns C[u][z] + IdentityMatrix[2] **)

RiemannHilbert`ScaledCauchyOperator[CmR_,Cmat_List][Ucx_]:=Join[AddIdentityMatrix[Cmat[[1]][Ucx[[2]]]]~FunListDot~AddIdentityMatrix[CmR[Ucx[[1]]]],AddIdentityMatrix[CmR[Ucx[[2]]]]~FunListDot~AddIdentityMatrix[Cmat[[2]][Ucx[[1]]]]
];
ScaledCauchyOperator[s_,slvrx_ScaledRHSolver]:=ScaledCauchyOperator[CauchyOperator[s,slvrx[[2]]],SetDomain[slvrx[[1,2,-1,1]],#]&/@(Function[scs,Function[gm,Fun[0&,scs[[1]]+scs[[2]]gm[[1]],gm[[2]]]]/@Last[slvrx]]/@First[slvrx])];

CauchyOperator[ScaledCauchyOperator[CmR_,Cmat_List]]:=FunValueListOperator[
Join[
RightJoin[CmR[[1]],Cmat[[1,1]]],
RightJoin[Cmat[[2,1]],CmR[[1]]]
],Join@@scCm[[2,All,-1]]];

RiemannHilbert`ConstructCurve[crvs:{{_,_}..},gls_List,x_]:=Join@@(ConstructCurve[Sequence@@#,x]&/@Thread[{crvs,gls}]);ConstructCurve[{scs_,domain_},gfs_,x_]:=Join@@(ConstructCurve[#,domain]&/@Thread[{scs[x]//Transpose,gfs//Transpose}]);
ConstructCurve[{{z0_,sc_},gs_},domain_]:=Fun[#[[1]],#[[2,1]]/sc +z0,#[[2,2]]]&/@Thread[{gs,domain}]; 


End[];
EndPackage[];
