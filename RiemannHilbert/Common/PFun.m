(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage[$CommonPackage];


PFun::usage="PFun[c0,p0,n] defines a function taking the value c0 and the point p0.";

PointDomainQ;
ToUnitPoint;


UnitPoint;
UnitPointFunQ;
MapToPoint;
MapFromPoint;
Begin["Private`"];

PointDomainQ[_Point]:=True;
PointDomainQ[_]:=False;

DomainQ[_?PointDomainQ]:=True;
DomainMemberQ[d_Point,x_]:=Abs[x-d[[1]]]<=10 $MachineTolerance;


UnitPoint=Point[0];
UnitPointFunQ[f_PFun]:=N[Domain[f]]==N[UnitPoint];
UnitPointFunQ[_]:=False;



MapToPoint[f_PFun,z_]:=MapToPoint[f//Domain,z];
MapFromPoint[f_PFun,z_]:=MapFromPoint[f//Domain,z];

MapToPoint[Point[z0_],z_]:=z-z0;
MapFromPoint[Point[z0_],z_]:=z+z0;

End[];



Begin["Private`"];


Points[Point[z0_],1]:={z0};

End[];



Begin["Private`"];


DomainPlot[Point[z0_],opts___]:=
Graphics[{Thick,Blue,PointSize[Large],Arrowheads[Medium],
Point[{Re[z0],Im[z0]}]},opts,Axes->True];


PFun[c0_,d_][z_]:=c0[[1]];
PFun[c0_?ScalarQ,d_]:=PFun[{c0},d];
PFun[c0:{_,_,___},d_]:=PFun[{c0},d];
PFun[f_?(NotListOrPatternQ[#]&&!ScalarQ[#] &&!ScalarQ[First[Flatten[#]]]&)&,d_,1]:=PFun[{f[d[[1]]]},d];
PFun[f_?(NotListOrPatternQ[#]&&!ScalarQ[#]&&!ScalarQ[First[Flatten[#]]]&)&,d_,opts:OptionsPattern[]]:=PFun[f,d,1];

FunQ[_PFun]:=True;

Values[PFun[c0_,_]]:=c0;
FiniteValues[pf_PFun]:=Values[pf];
Domain[PFun[_,d_]]:=d;

Length[if_PFun]^:=1;
Points[if_PFun]:={Domain[if][[1]]};

PFun/:Map[f_,g_PFun]:=PFun[f/@Values[g],Domain[g]];
FastPlus[f__PFun]:=PFun[Plus@@(Values/@{f}),Domain[{f}[[1]]]];
FastTimes[f__PFun]:=PFun[Times@@(Values/@{f}),Domain[{f}[[1]]]];
f_PFun+g_PFun^:=f~FastPlus~g;
Times[f_PFun,g_PFun]^:=f~FastTimes~g;
PFun/:f_?ConstantQ+g_PFun:=PFun[f+Values[g],g//Domain];
PFun/:g_PFun+f_?ConstantQ:=PFun[Values[g]+f,g//Domain];
PFun/:Times[f_?ConstantQ,g_PFun]:=PFun[f Values[g],g//Domain];
PFun/:Times[g_PFun,f_?ConstantQ]:=PFun[Values[g]f,g//Domain];
PFun/:f_PFun^c_?ConstantQ:=PFun[Values[f]^c,f//Domain];
PFun/:c_?ConstantQ^f_PFun:=PFun[c^Values[f],f//Domain];

Dot[f_PFun?ArrayFunQ,g_PFun?ArrayFunQ]^:=ToArrayFun[ToArrayOfFuns[f].ToArrayOfFuns[g]];

PFun/:Dot[f_List?(!ArrayFunQ[#]&),g_PFun?ArrayFunQ]:=ToArrayFun[f.ToArrayOfFuns[g]];


PMapToValues[op_]:=(op[if_PFun]^:=PFun[op[Values[if]],if//Domain]);
PMapToValues/@{Abs,Arg,Re,Im,Conjugate,Exp,Tan,ArcSin,Sec,Sin,Cos,Log,ArcTanh};

Max[f_PFun]^:=f//Values//Max;
Min[f_PFun]^:=f//Values//Min;
Norm[f_PFun]^:=f//Values//Flatten//Norm;
Mean[f_PFun]^:=f//Values//First;


NEqual[f_PFun,g_PFun]:=Norm[f-g]<$MachineTolerance;


PFun/:f_PFun?MatrixFunQ[[i_,j_]]:=(f//ToMatrixOfFuns)[[i,j]]//ToArrayFun;
PFun/:f_PFun?ListFunQ[[i_]]:=(f//ToArrayOfFuns)[[i]]//ToArrayFun;


FinitePoints[if_PFun]:=if//Points;

FiniteRealPoints[if_PFun]:=if//FinitePoints//Re;
End[];




Begin["Private`"];

ToUnitPoint[lf_PFun]:=SetDomain[lf,UnitPoint];
End[];




Begin["Private`"];


FromValueList[f_PFun?ScalarFunQ,ls_]:=PFun[ls,Domain[f]];
FromValueList[f_PFun?MatrixFunQ,ls_]:=PFun[{PartitionList[ls,f//Dimensions]},f//Domain];
FromValueList[f_PFun?VectorFunQ,ls_]:=PFun[{ls},f//Domain];


End[];






Begin["Private`"];


DiagonalMatrix[f_PFun]^:=f//Values//DiagonalMatrix;
IdentityMatrix[f_PFun]^:=f//Length//IdentityMatrix;


Fun[f_,d_?PointDomainQ,opts___]:=PFun[f,d,opts];



End[];
EndPackage[];
