(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["RiemannHilbert`",{"RiemannHilbert`Common`"}];


Cauchy::usage="Cauchy[f,z] evaluates the Cauchy transform \!\(\*FractionBox[\(1\), \(2\\\ \[Pi]\[NonBreakingSpace]I\)]\)\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - z\)]\)\[DifferentialD]t of an IFun f at a complex point z. Cauchy[ifunlist,z] evaluates the sum of the Cauchy transform of each element of ifunlist. Cauchy[\[PlusMinus]1,f,x] evaluates the left/right limit of Cauchy[f,x] for x on the domain of f. Cauchy[\[PlusMinus]1,flist] for CauchyBoundedQ[flist] true evaluates the Cauchy transform of flist on the points of flist, returning another list of IFuns.";
Hilbert::usage="Hilbert[f,x] evaluates the Hilbert transform \!\(\*FractionBox[\(1\), \(\[Pi]\)]\)PV\!\(\*SubscriptBox[\(\[Integral]\), \(Domain[f]\)]\)\!\(\*FractionBox[\(f[t]\), \(t - x\)]\)\[DifferentialD]t of an IFun f at a point x on Domain[f].";

CauchyInverse;
HilbertInverse;

CauchyMatrix;
CauchyS;

FPCauchyBasis;
CauchyBasis;
CauchyBasisS;
CauchyMatrix;


Begin["`Private`"];
Cauchy[lf_LFun,z_List]:=Cauchy[lf,#]&/@z;
Cauchy[s_?SignQ,lf_LFun,z_List]:=Cauchy[s,lf,#]&/@z;


CauchyS[-1,lf_LFun?UnitCircleFunQ,z_?InfinityQ]:=0;


CauchyS[+1,lf_LFun?UnitCircleFunQ,z_]:=NonNegativeEvaluate[lf,z];
CauchyS[-1,lf_LFun?UnitCircleFunQ,z_]:=-NegativeEvaluate[lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]<=1.&)]:=CauchyS[+1,lf,z];
Cauchy[lf_LFun?UnitCircleFunQ,z_?(Abs[#]>1.&)]:=CauchyS[-1,lf,z];
Cauchy[s_?SignQ,lf_LFun?UnitCircleFunQ,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyS[s,lf,z];
Cauchy[s_?SignQ,lf_LFun?UnitCircleFunQ,z_?ScalarQ]:=Cauchy[lf,z];

Cauchy[f:LFun[_,_Curve],z_?ScalarQ]:=Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[s_?SignQ,f:LFun[_,_Curve],z_?ScalarQ]/;DomainMemberQ[f,z]:=Total[Cauchy[s,f//ToUnitCircle,ComplexMapToCircle[f//Domain,z]]]-Total[Cauchy[f//ToUnitCircle,ComplexMapToCircle[f//Domain,10^18]]];

Cauchy[lf_LFun,z_?ScalarQ]:=Cauchy[lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Cauchy[s_?SignQ,lf_LFun,z_?ScalarQ]:=Cauchy[s,lf//ToUnitCircle,MapToCircle[lf,z]]-Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]];
Hilbert[lf_LFun,z_?ScalarQ]:=I (Cauchy[+1,lf,z]+Cauchy[-1,lf,z]);



CauchyInverse[+1,lf_LFun,z_]:=Cauchy[+1,lf,z];
CauchyInverse[-1,lf_LFun,z_]:=-Cauchy[-1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]<=1.:=CauchyInverse[+1,lf,z];
CauchyInverse[lf_LFun,z_]/;Abs[MapToCircle[lf,z]]>1.:=CauchyInverse[-1,lf,z];

HilbertInverse[lf_LFun,z_]:=-I (CauchyInverse[+1,lf,z]-CauchyInverse[-1,lf,z]);


Cauchy[+1,lf_LFun?UnitCircleFunQ]:=NonNegativePart[lf];
Cauchy[-1,lf_LFun?UnitCircleFunQ]:=-NegativePart[lf];

Cauchy[s_?SignQ,f:LFun[_,_Curve]]:=LFun[Cauchy[s,f,f//Points],f//Domain];

Cauchy[s_?SignQ,lf_LFun]:=LFun[Cauchy[s,lf//ToUnitCircle]//Values,lf//Domain]-ToArrayFun[Cauchy[lf//ToUnitCircle,MapToCircle[lf,\[Infinity]]] OneFun[lf]];
Hilbert[lf_LFun]:=I (Cauchy[+1,lf]+Cauchy[-1,lf]);

CauchyInverse[+1,lf_LFun]:=Cauchy[+1,lf];
CauchyInverse[-1,lf_LFun]:=-Cauchy[-1,lf];

HilbertInverse[lf_LFun]:=-I (CauchyInverse[+1,lf]-CauchyInverse[-1,lf]);

Cauchy[s_?SignQ,f_LFun,f_LFun]:=Cauchy[s,f];
Cauchy[s_?SignQ,f_LFun,g_?FunQ]:=Head[g][Cauchy[f,g//Points],g//Domain];
Cauchy[s_?SignQ,f:{__LFun},g_?FunQ]:=Cauchy[s,#,g]&/@f//Total;
Cauchy[s_?SignQ,f:{__LFun},g:{__LFun}]:=Cauchy[s,f,#]&/@g;

Cauchy[s_?SignQ,f_List]:=Cauchy[s,f,f];



CauchyBasis[_?SignQ,_Integer,_?InfinityQ]:=0;
CauchyBasisS[_?SignQ,_,_Integer,_?InfinityQ]:=0;



CauchyBasis[f_?FunQ,k_,x_]:=CauchyBasis[f//Domain,k,x];
CauchyBasis[s_?SignQ,f_?FunQ,k_,x_]:=CauchyBasis[s,f//Domain,k,x];

CauchyBasisS[f_?FunQ,k_,x_]:=CauchyBasisS[f//Domain,k,x];
CauchyBasisS[s_?SignQ,f_?FunQ,k_,x_]:=CauchyBasisS[s,f//Domain,k,x];

CauchyBasisS[+1,UnitCircle,k_?Negative,z_]:=0 z;
CauchyBasisS[-1,UnitCircle,k_?Negative,z_]:=-z^k;
CauchyBasisS[+1,UnitCircle,0,z_List]:=OneVector[Length[z]];
CauchyBasisS[+1,UnitCircle,0,z_]:=1;
CauchyBasisS[+1,UnitCircle,k_?NonNegative,z_]:=z^k;
CauchyBasisS[-1,UnitCircle,k_?NonNegative,z_]:=0 z;


CauchyBasis[d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[d,k,#]&/@z;
CauchyBasis[s_?SignQ,d_?CircleDomainQ,k_Integer,z_List]:=CauchyBasis[s,d,k,#]&/@z;


CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]<=1.&)]:=CauchyBasisS[+1,UnitCircle,k,z];
CauchyBasis[UnitCircle,k_Integer,z_?(Abs[#]>1.&)]:=CauchyBasisS[-1,UnitCircle,k,z];

CauchyBasis[s_?SignQ,UnitCircle,k_Integer,z_?(DomainMemberQ[UnitCircle,#]&)]:=CauchyBasisS[s,UnitCircle,k,z];
CauchyBasis[s_?SignQ,UnitCircle,k_Integer,z_]:=CauchyBasis[UnitCircle,k,z];


CauchyBasis[d:Curve[_LFun],0,z_]:=Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],0,z_]:=Total[CauchyBasis[s,UnitCircle,0,ComplexMapToCircle[d,z]]]-Total[CauchyBasis[UnitCircle,0,ComplexMapToCircle[d,10^18]]];
CauchyBasis[s_?SignQ,d:Curve[_LFun],k_Integer,z_]:=Total[CauchyBasis[s,UnitCircle,k,ComplexMapToCircle[d,z]]];

CauchyBasis[s_?SignQ,d:Curve[_LFun],i_Integer;;j_Integer,z_List]:=((Total/@CauchyBasis[s,UnitCircle,i;;j,#])&/@ComplexMapToCircle[d,z]//Transpose)-Count[ComplexMapToCircle[d,10^18],_?(Abs[#]<1&)]  ToList[BasisShiftList[i;;j,0]];


CauchyBasis[f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasis[s_?SignQ,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasis[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];
CauchyBasisS[s_?SignQ,f_?CircleDomainQ,k_Integer,z_]:=CauchyBasisS[s,UnitCircle,k,MapToCircle[f,z]]-CauchyBasis[UnitCircle,k,MapToCircle[f,\[Infinity]]];


CauchyBasisS[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasisS[s,d,k,z],{k,i,j}]];
CauchyBasis[d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[d,k,z],{k,i,j}]];
CauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,z_]:=Module[{k},Table[CauchyBasis[s,d,k,z],{k,i,j}]];



FPCauchyBasis[s_?SignQ,f_?FunQ,k_,g_?FunQ]:=FPCauchyBasis[s,f//Domain,k,g];

FPCauchyBasis[s_?SignQ,d_?CircleDomainQ,i_;;j_,lf_?FunQ]:=Fun[#,lf//Domain]&/@CauchyBasis[s,d,i;;j,lf//Points];

CauchyMatrix[s_?SignQ,lf_LFun?ScalarFunQ,lf2_?FunQ]:=Transpose[(FiniteValues/@FPCauchyBasis[s,lf,Span@@(lf//FFT//IndexRange),lf2])].FiniteTransformMatrix[lf];

CauchyMatrix[s_?SignQ,f_LFun]:=CauchyMatrix[s,f,f];


End[];
EndPackage[];
